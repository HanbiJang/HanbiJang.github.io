<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://hanbijang.github.io/</id><title>🎀Hanbi는 공부 중🎀</title><subtitle>반갑습니다 :)</subtitle> <updated>2022-07-13T17:43:58+09:00</updated> <author> <name>HanbiJang</name> <uri>https://hanbijang.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://hanbijang.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://hanbijang.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 HanbiJang </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>11~20번 중요 포인트</title><link href="https://hanbijang.github.io/posts/11-20%EB%AC%B8%EC%A0%9C-%EC%A0%95%EB%A6%AC/" rel="alternate" type="text/html" title="11~20번 중요 포인트" /><published>2022-07-13T00:00:00+09:00</published> <updated>2022-07-13T00:00:00+09:00</updated> <id>https://hanbijang.github.io/posts/11-20%EB%AC%B8%EC%A0%9C-%EC%A0%95%EB%A6%AC/</id> <content src="https://hanbijang.github.io/posts/11-20%EB%AC%B8%EC%A0%9C-%EC%A0%95%EB%A6%AC/" /> <author> <name>HanbiJang</name> </author> <category term="CodingTestStudy" /> <summary> 11~20번 중요 포인트 13번 가장 많이 사용된 자릿수 숫자열을 받고, 그 숫자열에서 가장 많이 쓴 자연수를 구해라 ⇒ 힌트 : 자연수의 인덱스에 해당하는 0~ 9까지의 배열을 만들고 해당 인덱스의 수를 문자열을 만날 때마다 증가시킨다 #include &amp;lt;stdio.h&amp;gt; int ch[10]; int main(){ int i, digit, max = -214000000, res; char a[101]; scanf("%s", &amp;amp;a); for(i=0; a[i]!= '\0';i++){ if(ch[i]&amp;gt;=max){ max = ch[i]; res = i; } printf("%d", res); return 0; } } 14 뒤집힌 소수 #in... </summary> </entry> <entry><title>13강 SpinLock 구현</title><link href="https://hanbijang.github.io/posts/13%EA%B0%95-SpinLock/" rel="alternate" type="text/html" title="13강 SpinLock 구현" /><published>2022-06-24T00:00:00+09:00</published> <updated>2022-06-24T00:00:00+09:00</updated> <id>https://hanbijang.github.io/posts/13%EA%B0%95-SpinLock/</id> <content src="https://hanbijang.github.io/posts/13%EA%B0%95-SpinLock/" /> <author> <name>HanbiJang</name> </author> <category term="GameServer" /> <summary> 13강 SpinLock 구현 ⭐⭐⭐ 면접에서 자주 나옴 (구현 해보았는지) ⇒ 뺑뺑이 (무한대기)를 하면서 컴파일 앤 스왑 하는 방법 using System; using System.Threading; using System.Threading.Tasks; namespace ServerCore { //lock을 획득할 때까지 무한정 대기하는 데드락 해결 방법 (문제 있는 코드 방식) class SpinLock { volatile bool locked = false; public void Acquire() { while (locked) { //lock이 풀리기를 대기함 ... </summary> </entry> <entry><title>12강 Lock 구현 이론</title><link href="https://hanbijang.github.io/posts/12%EA%B0%95-%EB%9D%BD%EA%B5%AC%ED%98%84-%EC%9D%B4%EB%A1%A0/" rel="alternate" type="text/html" title="12강 Lock 구현 이론" /><published>2022-06-22T00:00:00+09:00</published> <updated>2022-06-22T00:00:00+09:00</updated> <id>https://hanbijang.github.io/posts/12%EA%B0%95-%EB%9D%BD%EA%B5%AC%ED%98%84-%EC%9D%B4%EB%A1%A0/</id> <content src="https://hanbijang.github.io/posts/12%EA%B0%95-%EB%9D%BD%EA%B5%AC%ED%98%84-%EC%9D%B4%EB%A1%A0/" /> <author> <name>HanbiJang</name> </author> <category term="GameServer" /> <summary> 12강 Lock 구현 이론 문제 상황 화장실에 이미 사람이 있다면? 해결 1 - 다 끝나고 나올때까지 존버하기 단점 : 시간 낭비 CPU 점유율이 확 올라가버릴 수도 있다 = 스핀락의 개념 해결 2 - 조금 후 돌아오기 (다른일 하다가) 단점 : 확실히 내가 들어갈 수 있는지에 랜덤성이 있다 (다른 사람이 또 들어갈수도) 작업을 옮겨 다니는 것에도 부담이 든다 장점 : 효율적이긴 함 = 스레드 의 소유권을 포기하는 방식 해결 3 - 직원에게 나오면 알려달라고 하기 단점 : 직원을 거쳐서 하다보니 부담이 든다 (이러한 방식의 사람이 많다면) 장점 : 기다릴 필요도 없고 효율적이다 = 이벤트 방식 </summary> </entry> <entry><title>11강 데드락</title><link href="https://hanbijang.github.io/posts/11%EA%B0%95-%EB%8D%B0%EB%93%9C%EB%9D%BD/" rel="alternate" type="text/html" title="11강 데드락" /><published>2022-06-22T00:00:00+09:00</published> <updated>2022-06-22T00:00:00+09:00</updated> <id>https://hanbijang.github.io/posts/11%EA%B0%95-%EB%8D%B0%EB%93%9C%EB%9D%BD/</id> <content src="https://hanbijang.github.io/posts/11%EA%B0%95-%EB%8D%B0%EB%93%9C%EB%9D%BD/" /> <author> <name>HanbiJang</name> </author> <category term="GameServer" /> <summary> 11강 데드락 데드락 발생 상황 스토리로 풀어보기 사람이 2명 있다 2명이 모두 자물쇠를 하나씩 가지고 있다 자물쇠가 2개 있고 이를 모두 획득해야 방에 들어갈 수 있다 서로의 자물쇠를 획득해야지만 하는 상황 class SessionManager{ static object lock_ = new object(); void TestSession(){ lock(lock_){} } void Test(){ lock(lock_){} } } class UserManger{ static object lock_ = new object(); void Test(){ lock(lock_){ TestSession(); } } //...(생략) } ... </summary> </entry> <entry><title>9강 InterLocked</title><link href="https://hanbijang.github.io/posts/9%EA%B0%95-InterLocked/" rel="alternate" type="text/html" title="9강 InterLocked" /><published>2022-06-16T00:00:00+09:00</published> <updated>2022-06-16T00:00:00+09:00</updated> <id>https://hanbijang.github.io/posts/9%EA%B0%95-InterLocked/</id> <content src="https://hanbijang.github.io/posts/9%EA%B0%95-InterLocked/" /> <author> <name>HanbiJang</name> </author> <category term="GameServer" /> <summary> 9강 InterLocked 부제: 경합 조건 (Race condition) 공유 변수 접근의 문제점 class Program{ static int num = 0; static object obj = new object(); static void Tread_1(){ for(int i=0; i&amp;lt; 10000; i++){ num++; } } static void Tread_2(){ for (int i=0; i&amp;lt;10000; i++){ num--; } } } //... //스레드들 실행시키는 구문 10000번씩 1씩 더하고 1씩 빼는 코드 결과로 0이 나온... </summary> </entry> </feed>
