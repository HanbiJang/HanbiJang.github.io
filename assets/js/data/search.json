[ { "title": "11~20번 중요 포인트", "url": "/posts/11-20%EB%AC%B8%EC%A0%9C-%EC%A0%95%EB%A6%AC/", "categories": "CodingTestStudy", "tags": "CodingTestStudy", "date": "2022-07-13 00:00:00 +0900", "snippet": "11~20번 중요 포인트13번 가장 많이 사용된 자릿수숫자열을 받고, 그 숫자열에서 가장 많이 쓴 자연수를 구해라⇒ 힌트 : 자연수의 인덱스에 해당하는 0~ 9까지의 배열을 만들고 해당 인덱스의 수를 문자열을 만날 때마다 증가시킨다#include &lt;stdio.h&gt;int ch[10];int main(){\tint i, digit, max = -214000000, res;\tchar a[101];\tscanf(\"%s\", &amp;a);\tfor(i=0; a[i]!= '\\0';i++){\t\tif(ch[i]&gt;=max){\t\t\tmax = ch[i];\t\t\tres = i;\t\t}\tprintf(\"%d\", res);\treturn 0;\t}}14 뒤집힌 소수#include &lt;stdio.h&gt;int reverse(int x){\tint res = 0, tmp = 0;\twhile(x&gt;0) {\t\ttmp = x % 10;\t\tres = res*10 + tmp;\t\tx = x/10;\t}\treturn res;}//소수판별bool isPrime( int x ){\tint i;\tif(x==1) return false;\tbool flag = true;\tfor (i = 2; i&lt;x; i++){\t\t\tif(x%i == 0) flag=false; break;\t}\treturn flag;}int main(){\tint n, num, i ,newNum;\tscanf(\"%d\", &amp;n);\tfor(i=0; i&lt;=n; i++){\t\tscanf(\"%d\", &amp;num);\t\tnewNum= reverse(num);\t\tif(isPrime(tmp)) printf(\"%d\", tmp);\t}\treturn 0;}reverse 가 중요함 (맨날 헷갈리는 문제중 하나)++) 입력 수가 여러개면 그만큼 여러개 돌아가게 됨!입력 수, 결과, tmp 필요함 결과 = 뒤집힌 수가 결과로 들어옴 tmp = 숫자의 맨 뒷 숫자입력 수는 반복문 한번이 지날때마다 맨뒷숫자가 사라짐.tmp = 입력 수 %10결과 = 이전결과 * 10 + 맨뒷숫자입력수의 맨뒷숫자 날리기(입력수가 0이 아니게 될때까지 반복)15번 소수의 갯수 (1초)시간 초과 주의 !내 방법 :sqart 사용하기 🙅‍♀️정답: sqart 사용 안하고 풀기⭕//sqart 사용 안하기!for(j = 2; **j * j &lt;= i**; j++){\t//...}16번 아나그램 (Anagram) (구글 인터퓨 문제)⇒ 두 문자열을 비교해서 문자의 구성이 같으면 트루, 아니면 팔스를 출력한다구성 비교 풀이 방법배열을 비교할 만큼 만들어서 반복문 돌려서 인덱스에 넣고 비교한다이 문제에서는 a 배열에 문자들을 넣고 반복문 하나하나 돌려서 구성이 있으면 카운트한다프로그램 종료함수를 안 쓰고 main 에서 프로그램을 종료하기exit(0);⇒ 이거하면 return 0; 을 만나지 않아도 프로그램 종료됨아스키 코드대문자 : 65 ~ 90소문자 : 97~ 12217번 선생님 퀴즈한번에 여러개 변수 입력 받기 ⚠️까먹지 말기scanf(\"%d %d\", &amp;a, &amp;b);C++ 서식 문자 정리 서식 문자 타입 %d int %c char %s char* %lf double %f float 18번 층간 소음로직이 중요 문제 : 한 세대의 측정치가 M값을 넘으면 경보음이 울린다. 한 세대의 N초 동안의 실시간 측정치가 주어지면 최대로 경보음이 울린 시간은? (단, 경보음이 없다면 -1을 출력하기) 해답 로직 : 반복문을 돌리며 현재 측정치가 M값을 넘으면 카운트한다. 이때 카운트가 최대 값보다 크다면 최대값은 카운트값으로 한다. 출력은 최대값으로 한다 ⚠️주의할 점 : 예외 처리 - -1 출력하기 ⇒ 위 반복문을 이후에도 max값이 처음과 변함이 없다면 결과를 -1로 출력19번 분노 유발자 문제 : 앉은 키들이 주어짐. 한줄로 앉은 학생들 에 대해서 앞 사람이 뒷사람 모두를 못보게 가리는 분노유발자들을 카운트해서 출력해라 앞→ 뒤로 비교하는 방법의 문제점: 학생 한명 당 뒷사람의 키가 더큰지 아닌지 모르기때문에 나머지 뒷사람들에 대해서도 비교를 해주어야 하므로 반복문이 2개나 쓰임 뒤→ 앞 비교하는 방법 : 위를 해결함. 뒤에서 부터 비교하여 가장 큰 학생의 키만 저장해놓으면 앞으로 가며 비교하므로 해당 학생이 분노 유발자인지 아닌지 구별 가능함20번 가위바위보로직이 중요함가위바위보의 승리를 비교하는 비교문이 적어야 깨끗한 코드됨⇒ 한명의 입장에서만 이기는 경우를 센다면 그 이외의 경우는 (=else) 다른 사람이 이기는 경우다if(비기는 경우)else if(A가 보자기로 이김)else if(A가 가위로 이김)else if(A가 바위로 이김)else == A가 지는 모든 경우⇒ 누구든지 상관없이, 이겼을때와 졌을때가 해주는 액션이 동일하므로 이렇게 깔끔하게 가능함" }, { "title": "13강 SpinLock 구현", "url": "/posts/13%EA%B0%95-SpinLock/", "categories": "GameServer", "tags": "GameServer", "date": "2022-06-24 00:00:00 +0900", "snippet": "13강 SpinLock 구현⭐⭐⭐면접에서 자주 나옴 (구현 해보았는지)⇒ 뺑뺑이 (무한대기)를 하면서 컴파일 앤 스왑 하는 방법using System;using System.Threading;using System.Threading.Tasks;namespace ServerCore{ //lock을 획득할 때까지 무한정 대기하는 데드락 해결 방법 (문제 있는 코드 방식) class SpinLock { volatile bool locked = false; public void Acquire() { while (locked) { //lock이 풀리기를 대기함 } //lock이 풀렸다면 locked = true; } public void Release() { locked = false; } } class Program { static int num = 0; //코드들이 원자적으로 실행이 되는지 판단하기 위한 변수. 의도한 값: 0이 나와야 함 static SpinLock myLock = new SpinLock(); //스핀락 클래스 객체 myLock static void Thread_1() { for (int i = 0; i &lt; 1000000; i++) { myLock.Acquire(); //lock을 얻을 때까지 무한정 대기 num++; myLock.Release(); } } static void Thread_2() { for (int i = 0; i &lt; 1000000; i++) { myLock.Acquire(); //lock을 얻을 때까지 무한정 대기 num--; myLock.Release(); } } static void Main(string[] args) { //실행하기 Task t1 = new Task(Thread_1); Task t2 = new Task(Thread_2); t1.Start(); t2.Start(); Task.WaitAll(t1, t2); //대기가 취소되지 않는 경우 제공된 모든 Task 개체가 실행을 완료하기를 기다립니다. //결과 출력 Console.WriteLine(num); // 0이 나와야 코드들이 원자적으로 실행된 것임 //====== //결과 : 이상한 값 1766 } }}⇒ 0이 나와야 하지만⇒ 이상한 값이 나옴 두 스레드가 동시에 락을 가져가려고 하게 때문에 오류가 발생함 코드가 원자적으로 실행이 되어야 함문제 부분 //lock을 획득할 때까지 무한정 대기하는 데드락 해결 방법 (문제 있는 코드 방식) class SpinLock { volatile bool locked = false; public void Acquire() { while (locked) { //lock이 풀리기를 대기함 } //lock이 풀렸다면 locked = true; } public void Release() { locked = false; } } while문 때문에 계속 대기하게 된다 ⇒ 해결 : Interlocked 함수 해결 버전 1 //lock을 획득할 때까지 무한정 대기하는 데드락 해결 방법 (올바른 스핀락 구현 법) class SpinLock { volatile int locked = 0; //Exchange 위해 타입을 바꿔줌 public void Acquire() { while (true) { //[1] 버전-1 int origin = Interlocked.Exchange(ref locked, 1);//원자 단위 연산으로 단정밀도 부동 소수점 숫자를 지정된 값으로 설정하고 원래 값을 반환합니다. // 값을 1로 exchange == lock을 잠근다 if (origin == 0) break;//origin 값이 0일때 == lock이 풀려있는 상태였을 때, lock을 얻었으므로 while 반복문 탈출 } } 해결 버전 2 //lock을 획득할 때까지 무한정 대기하는 데드락 해결 방법 (올바른 스핀락 구현 법) class SpinLock { volatile int locked = 0; //Exchange 위해 타입을 바꿔줌 public void Acquire() { while (true) { //[2] 버전-2 (더 가독성 좋은 코드) int expectedValue = 0; //의도한 num의 값 int desired = 1; //CompareExchange : locked 값이 expectedValue값과 같다면 desired 값으로 바꿔준다 // == locked 값이 0 일 때 1을 대입해준다 if (Interlocked.CompareExchange(ref locked, desired, expectedValue) == expectedValue) { break; } } }코드 정리스핀락 - 문제 있는 코드 구현(이상한 값 출력)using System;using System.Threading;using System.Threading.Tasks;namespace ServerCore{ //lock을 획득할 때까지 무한정 대기하는 데드락 해결 방법 (문제 있는 코드 방식) class SpinLock { volatile bool locked = false; public void Acquire() { while (locked) { //lock이 풀리기를 대기함 } //lock이 풀렸다면 locked = true; } public void Release() { locked = false; } } class Program { static int num = 0; //코드들이 원자적으로 실행이 되는지 판단하기 위한 변수. 의도한 값: 0이 나와야 함 static SpinLock myLock = new SpinLock(); //스핀락 클래스 객체 myLock static void Thread_1() { for (int i = 0; i &lt; 1000000; i++) { myLock.Acquire(); //lock을 얻을 때까지 무한정 대기 num++; myLock.Release(); } } static void Thread_2() { for (int i = 0; i &lt; 1000000; i++) { myLock.Acquire(); //lock을 얻을 때까지 무한정 대기 num--; myLock.Release(); } } static void Main(string[] args) { //실행하기 Task t1 = new Task(Thread_1); Task t2 = new Task(Thread_2); t1.Start(); t2.Start(); Task.WaitAll(t1, t2); //대기가 취소되지 않는 경우 제공된 모든 Task 개체가 실행을 완료하기를 기다립니다. //결과 출력 Console.WriteLine(num); // 0이 나와야 코드들이 원자적으로 실행된 것임 //====== //결과 : 이상한 값 1766 } }}스핀락 - 올바른 해결using System;using System.Threading;using System.Threading.Tasks;namespace ServerCore{ //lock을 획득할 때까지 무한정 대기하는 데드락 해결 방법 (올바른 스핀락 구현 법) class SpinLock { volatile int locked = 0; //Exchange 위해 타입을 바꿔줌 public void Acquire() { while (true) {/* //[1] 버전-1 int origin = Interlocked.Exchange(ref locked, 1); //원자 단위 연산으로 단정밀도 부동 소수점 숫자를 지정된 값으로 설정하고 원래 값을 반환합니다. // 값을 1로 exchange == lock을 잠근다 if (origin == 0) break; //origin 값이 0일때 == lock이 풀려있는 상태였을 때, lock을 얻었으므로 while 반복문 탈출*/ //[2] 버전-2 (더 가독성 좋은 코드) int expectedValue = 0; //의도한 num의 값 int desired = 1; //CompareExchange : locked 값이 expectedValue값과 같다면 desired 값으로 바꿔준다 // == locked 값이 0 일 때 1을 대입해준다 if (Interlocked.CompareExchange(ref locked, desired, expectedValue) == expectedValue) { break; } } } public void Release() { locked = 0; } } class Program { static int num = 0; //코드들이 원자적으로 실행이 되는지 판단하기 위한 변수. 의도한 값: 0이 나와야 함 static SpinLock myLock = new SpinLock(); //스핀락 클래스 객체 myLock static void Thread_1() { for (int i = 0; i &lt; 1000000; i++) { myLock.Acquire(); //lock을 얻을 때까지 무한정 대기 num++; myLock.Release(); } } static void Thread_2() { for (int i = 0; i &lt; 1000000; i++) { myLock.Acquire(); //lock을 얻을 때까지 무한정 대기 num--; myLock.Release(); } } static void Main(string[] args) { //실행하기 Task t1 = new Task(Thread_1); Task t2 = new Task(Thread_2); t1.Start(); t2.Start(); Task.WaitAll(t1, t2); //대기가 취소되지 않는 경우 제공된 모든 Task 개체가 실행을 완료하기를 기다립니다. //결과 출력 Console.WriteLine(num); // 0이 나와야 코드들이 원자적으로 실행된 것임 //====== //결과 : 올바른 값 0 } }} 알아야 할 점 : stack 에 있는 변수 값은 경합이 일어나지 않는다 ! interlocked.exchange 를 쓰는 이유 : 코드가 여러줄에 걸쳐 있으면 코드가 스레드에 나뉘어 돌면서 문제가 생김 ⇒ int origin = Interlocked.Exchange(ref locked, 1); 아래의 코드를 한줄로 나타낸 것임 int origin = locked; locked = 1; . " }, { "title": "12강 Lock 구현 이론", "url": "/posts/12%EA%B0%95-%EB%9D%BD%EA%B5%AC%ED%98%84-%EC%9D%B4%EB%A1%A0/", "categories": "GameServer", "tags": "GameServer", "date": "2022-06-22 00:00:00 +0900", "snippet": "12강 Lock 구현 이론문제 상황화장실에 이미 사람이 있다면?해결 1 - 다 끝나고 나올때까지 존버하기 단점 : 시간 낭비 CPU 점유율이 확 올라가버릴 수도 있다 = 스핀락의 개념해결 2 - 조금 후 돌아오기 (다른일 하다가) 단점 : 확실히 내가 들어갈 수 있는지에 랜덤성이 있다 (다른 사람이 또 들어갈수도) 작업을 옮겨 다니는 것에도 부담이 든다 장점 : 효율적이긴 함 = 스레드 의 소유권을 포기하는 방식해결 3 - 직원에게 나오면 알려달라고 하기 단점 : 직원을 거쳐서 하다보니 부담이 든다 (이러한 방식의 사람이 많다면) 장점 : 기다릴 필요도 없고 효율적이다 = 이벤트 방식" }, { "title": "11강 데드락", "url": "/posts/11%EA%B0%95-%EB%8D%B0%EB%93%9C%EB%9D%BD/", "categories": "GameServer", "tags": "GameServer", "date": "2022-06-22 00:00:00 +0900", "snippet": "11강 데드락데드락 발생 상황스토리로 풀어보기 사람이 2명 있다 2명이 모두 자물쇠를 하나씩 가지고 있다 자물쇠가 2개 있고 이를 모두 획득해야 방에 들어갈 수 있다 서로의 자물쇠를 획득해야지만 하는 상황class SessionManager{\tstatic object lock_ = new object();\tvoid TestSession(){\t\tlock(lock_){}\t}\tvoid Test(){\t\tlock(lock_){}\t}}class UserManger{\tstatic object lock_ = new object();\tvoid Test(){\t\tlock(lock_){\t\t\tTestSession();\t\t}\t}\t//...(생략)} 서로 락을 획득하려고 하는 상황임Monitor.Transfer() ⇒ 실패처리하는 코드데드락 상황의 해결static void Main(string[] args){\tTask t1 = new Task(Thread_1);\tTask t2 = new Task(Thread_2);\tt1.Start();//====\tThread.Sleep(100);\tt2.Start();//====\tTask.WaitAll(t1,t2);} 정말 조금의 (0.1초…)시간 차를 두어서 2번째 스레드가 지연되어 실행되도록 한다 데드락 상황이 일어나지 않고 잘 실행이 된다+) 라이브 서비스 하는 게임에서 데드락 막는 것은 더더 어렵다" }, { "title": "9강 InterLocked", "url": "/posts/9%EA%B0%95-InterLocked/", "categories": "GameServer", "tags": "GameServer", "date": "2022-06-16 00:00:00 +0900", "snippet": "9강 InterLocked부제: 경합 조건 (Race condition)공유 변수 접근의 문제점class Program{\tstatic int num = 0;\tstatic object obj = new object();\tstatic void Tread_1(){\t\tfor(int i=0; i&lt; 10000; i++){ num++;\t\t}\t} static void Tread_2(){ for (int i=0; i&lt;10000; i++){ num--; } }}//...//스레드들 실행시키는 구문 10000번씩 1씩 더하고 1씩 빼는 코드 결과로 0이 나온다 (나와야 한다) ⇒ 하지만 이상한 값이 나오네? int number에 volatile 키워드를 붙여도 똑같이 이상한 값이 나옴경합 조건Race condition스토리와 비교 손님 1명과 직원 3명 손님이 콜라 하나를 주문시킴 직원 3명이 하나씩 콜라를 가져다줌 손님은 별안간 콜라가 3개를 받게됨 == 경합 조건 발생한 것 !++ 연산자의 실행 원리num++;위 코드의 어셈블리 코드에서의 실행 원리는 다음과 같다int tmp = num;tmp += 1;num = tmp; 도 위에서 tmp -= 1; 일뿐 마찬가지이다. 스레드에서 이 코드가 실행되는 도중 경합이 일어나게 되어서 이상한 값이 나온 것 같다.Interlocked 를 이용한 해결법class Program{\tstatic int num = 0;\tstatic object obj = new object();\tstatic void Tread_1(){\t\tfor(int i=0; i&lt; 10000; i++){ Interlocked.Increment(ref num);\t\t}\t} static void Tread_2(){ for (int i=0; i&lt;10000; i++){ Interlocked.Decrement(ref num); } }}// ...//스레드들 실행시키는 구문 ++은 Interlocked.Incremnt(ref num) 은 Interlocked.Decrement(ref num) 스레드 1과 2의 (1) ++과 (2) - - 작업이 원자적으로 일어나게 된다 원자적 := 순차적으로 (1) 작업 뒤에 (2) 작업이 일어나게 된다 (순서가 보장됨)Interlocked.increment (ref num) 에서 ref의 사용실제 num ‘값’이 아니라 num의 주소를 가져와서 레퍼런스를 사용함Interlock.Decrement () 의 단점대부분 정수만 사용가능사용할 수 있는 것이 한정되어 있음" }, { "title": "10강 Lock 기초", "url": "/posts/10%EA%B0%95-Lock%EA%B8%B0%EC%B4%88/", "categories": "GameServer", "tags": "GameServer", "date": "2022-06-16 00:00:00 +0900", "snippet": "01강 Lock 기초int temp = number; 등과 같이 쓰는 작업이 들어갔을 시 문제가 생기는 부분이 있을 수 있음⇒ 임계영역 (다른 스레드가 참견하면 문제가 생기는 코드 영역)임계영역을 만들기class Program{\tstatic int num = 0;\tstatic object obj = new object();\tstatic void Tread_1(){\t\tfor(int i=0; i&lt; 10000; i++){\t\t\tMonitor.Enter(obj);\t\t\t{\t\t\t\tnum++;\t\t\t}\t\t\tMonitor.Exit(obj);\t\t}\t}}Monitor.EnterMonitor.Exit을 사용하여 임계영역 지켜내기스토리와 비교 화장실에 들어가서 문을 잠그기 문을 잠금 풀기2와 3 사이에 쓰고자 하는 코드를 적어줌상호배제의 개념 (Mutual Exclusive) 2와 3 사이의 코드는 그 스레드만 처리할 것임 (싱글 스레드같이)Monitor.Exit 을 해주지 않고 끝냈을 때아래와 같이 스레드2에 데드락 현상이 일어난다 (무한 대기)class Program{\tstatic int num = 0;\tstatic object obj = new object();\tstatic void Tread_1(){\t\tfor(int i=0; i&lt; 10000; i++){ Monitor.Enter(obj); { num++; return; } Monitor.Exit(obj);\t\t}\t} static void Tread_2(){ for (int i=0; i&lt;10000; i++){ Monitor.Enter(obj); num--; Monitor.Exit(obj); } }} 스레드 1에서 Monitor.Enter(~)을 해준후, .Exit(~)을 해주지 않고 return 을 하여 스레드를 끝냄으로써 스레드2가 데드락 상태에 빠진다.일반적인 상황에서 사용하는 법 try ~ finally구문을 사용한다class Program{\tstatic int num = 0;\tstatic object obj = new object();\tstatic void Tread_1(){\t\tfor(int i=0; i&lt; 10000; i++){ try{ Monitor.Enter(obj); num++ return; } finally{ Monitor.Exit(obj); }\t\t}\t} static void Tread_2(){ for (int i=0; i&lt;10000; i++){ Monitor.Enter(obj); num--; Monitor.Exit(obj); } }}try ~ 뒤에 있는 finally가 try 에 결과와는 상관 없이 무조건 한번 실행되기 때문에숫자를 0으로 나누던가 하는 등의 오류때문에 프로그램이 Exit 없이 종료 시 이를 해결할 수 있게 됨 위 코드에서는 return 을 해주더라도 finally가 실행됨Lock 을 사용한 데드락 해결 (더 일반적, 추천)class Program{\tstatic int num = 0;\tstatic object obj = new object();\tstatic void Tread_1(){\t\tfor(int i=0; i&lt; 10000; i++){ lock(obj){ num++ }\t\t}\t}...obj 라는 것을 lock 으로 잠구고 {}을 빠져나가면 다시 알아서 열어준다" }, { "title": "8강 메모리 베리어", "url": "/posts/8%EA%B0%95-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B2%A0%EB%A6%AC%EC%96%B4/", "categories": "GameServer", "tags": "GameServer", "date": "2022-04-20 00:00:00 +0900", "snippet": "8강 메모리 베리어[1] 하드웨어 최적화컴파일러도 최적화를 하지만, 하드웨어도 최적화를 한다class Program { static int x = 0; static int y = 0; static int r1 = 0; static int r2 = 0; //하드웨어 최적화 static void Thread_1() { /*[1]*/y = 1; //store y /*[2]*/r1 = x; // load x } static void Thread_2() { /*[3]*/x = 1; //store x /*[4]*/r2 = y; //load y } static void Main(string[] args) { int cnt = 0; while (true) { cnt++; x = y = r1 = r2 = 0; //모두 0을 넣는다 Task t1 = new Task(Thread_1); Task t2 = new Task(Thread_2); t1.Start(); t2.Start(); Task.WaitAll(t1, t2); //이부분이 중요! //[1][2][3][4] 경우를 순서대로 조합해보아도 둘다 0이 되는 경우는 존재하지 않는다! //그러나 실행해보면 끝이난다 if (r1 == 0 &amp;&amp; r2 == 0) break; } Console.WriteLine($\"{cnt} 번 만에 빠져나옴\"); } } 2개의 스레드의 다음 코드 [1] y = 1; [2] r1 = x; [3] x = 1; [4] r2 = y; if (r1 == 0 &amp;&amp; r2 == 0) break; [1][2][3][4] 경우를 순서대로 조합해보아도 둘다 0이 되는 경우는 존재하지 않지만, break로 종료가 된다! ⇒ 이유가 뭘까?? ⇒ 하드웨어가 최적화를 하기 때문이다하드웨어가 코드의 순서대로 실행하지 않고 스레드내의 코드의 순서를 바꾸기 때문이다 최적화의 코드의 순서 [2] r1 = x; 4] r2 = y; 👇 [1] y = 1; [3] x = 1; ### Store과 Load y = 1; 그냥 **실제 값을 넣는 것 r1 = x; 변수에서 값을 끄집어 내는 것 x에서 값을 끄집어내서 할당하고 있음 [2] 메모리 베리어[1] 하는 이유 코드 재배치 억제 ([1]과 같은 경우) 가시성이 좋다[2] 메모리베리어 작동메모리 베리어 하는 법 Thread.MemoryBarrier()static void Thread_1() { /*[1]*/y = 1; //store y Thread.MemoryBarrier(); //메모리 베리어 /*[2]*/r1 = x; // load x }static void Thread_2() { /*[3]*/x = 1; //store x Thread.MemoryBarrier(); //메모리 베리어 /*[4]*/ r2 = y; //load y }[3] 메모리 베리어의 종류[1] Full Memory Barrier 🌟 메모리에서 Store , Load를 둘다 막는다[2] Store Memory Barrier Store만 막는다[3] Load Memory Barrier Load만 막는다가시성 (메모리베리어의 작동 원리) 메모리 베리어는 가시성이 좋다[1] 메모리 베리어의 역할스토리 텔링으로🧑직원이 주문 받은 내역을 🔖주문현황에 옮기고, 🧑🏻다른 직원이 그 주문현황을 바탕으로 자신의 📘수첩을 업데이트 하는 행위와 같다⇒ 값을 최신의 값으로 따끈따근하게 💛업데이트💛 하는 것과 같다 (가시성에 도움!) Thread.MemotyBarrier();을 쓴 코드 윗단의 가시성을 보장한다⇒ 정리하면, 메모리 베리어는 중앙 메모리에서 변수의 실제 현재 값을 가져오는 것이다 volatile 도 메모리 베리어 의 역할을 간접적으로 하고 있는 것이다 Lock, 아토믹도 간접적이다 메모리 베리어 예제int ans;bool complete;void A(){\tans = 123;\tThread.MemoryBarrier();\tcomplete = true;\tThread.MemotyBarrier();}void B(){\tThread.MemotyBarrier();\tif(complete){\t\tThread.MemotyBarrier();\t\tConsole.WriteLine(ans);\t}} complete = true;Thread.MemotyBarrier(); 코드가 끝난 부분에도 메모리 베리어를 해줌으로써 가시성을 확실히 보장함 원하는 결과가 나올 것임 …" }, { "title": "7강 캐시 이론", "url": "/posts/7%EA%B0%95-%EC%BA%90%EC%8B%9C-%EC%9D%B4%EB%A1%A0/", "categories": "GameServer", "tags": "GameServer", "date": "2022-04-18 00:00:00 +0900", "snippet": "7강 캐시 이론[1] 캐시란 무엇일까[1]스토리텔링상황🍴 레스토랑에서 주문을 받음🔖 주문 현황이 적힌 스크립트가 주방에 들어가면 주문이 접수되는 구조🧑🧑‍🦰 주문을 받는 식당 직원이 여러 명인 상황🧑식당 직원1이 사이다를 주문받았고, 이 사람이 다른 일을 하러가는 도중에같은 테이블에서 🧑‍🦰식당 직원2에게 사이다 말고 콜라로 바꿔달라는 주문을 넣었다!이때 주문 현황 판에 한번에 많이 쓰는 것이 효율적이므로,식당 직원이 기억해서 📘 미니 수첩에 적고,⇒ 이를 나중에 🔖 주문 현황에 업데이트 하는 구조가 됨🧑‍🦰 曰 : “예? 주문 현황이랑 제 수첩에는 사이다 주문에 대한 얘기는 아무것도 없는데요 …”⇒ 🧑 🧑‍🦰 주문을 받는 식당 직원이 여러 명인 탓에 혼란이 일어난다 ![2] CPU의 구조CPU는 코어로 구성됨 코어의 구성 : ALU : 연산장치 캐시장치 : 기억장치 식당 직원들이 🔖 주문현황을 업데이트 하기위해 개인 수첩들을 사용하는 것처럼 📘 미니수첩 = 레지스터, L1 캐시, L2 캐시 등의 기억장치들이 있다 🔖 주문현황 = RAM (기억 메모리)[2] 캐시의 철학캐시는 다음과 같은 철학을 바탕으로 만들어졌다 [1] Temporal Locality 시간적으로 보면, 방금 최신 주문한 테이블에서 추가 주문이 나올 확률이 높다 ⇒ 최신 주문을 메모해 놓으면 편할 것이다 (추가) 주문 = (재) 사용 [2] Spacial Locality 공간적으로 보면, 방근 주문한 사람 근처에 있는 사람이 추가 주문할 확률이 높다 ⇒ 최신 주문한 사람과 합석하는 사람들의 주문들도 메모해놓으면 편할 것이다 (추가) 주문 = (재) 사용[3] 멀티 스레드 환경의 문제 직원이 여러명일 시 문제 이 스토리텔링은 멀티 스레드 환경의 문제를 나타내는데, 이는 다음과 같음⇒ 어떤 값이 있고, 멀티스레드 환경일 때CPU마다 🧑코어가 있고 각각의 📘캐시가 존재할 것임.코드 상에서 내가 🧑스레드에서 어떤 값을 바꿨다고 해도 멀티스레드 이기 때문에100% 확률로 바뀐 값이 🔖메모리에 올라가는 것이 아니라,🧑‍🦰 입장에서는 바뀌지 않은 구버전의 값을 🔖메모리에 올려버릴 수도 있는 것임[4] 캐시의 작동static void Main(string[] args)\t\t\t\t{ //캐시의 작동을 확인하기 //결과 : //(y,x) 순서 걸린시간 : 2196603 //(x, y) 순서 걸린시간: 3814860 int[,] arr = new int[10000, 10000]; { long start = DateTime.Now.Ticks; //시작 시간 알아보기 // [][][][][] ... 메모리 상 인접한 순으로 열 -&gt; 행 으로 진행 for (int y = 0; y &lt; 10000; y++) { for (int x = 0; x &lt; 10000; x++) arr[y, x] = 1; } long end = DateTime.Now.Ticks; //끝난 시간 알아보기 Console.WriteLine($\"(y,x) 순서 걸린시간 : {end - start}\"); } { //스코프 나누기 // [] [] [] [] ... 이 순서로 행-&gt; 열 순서로 진행 메모리상 인접하지 않은 순서로 진행 long start = DateTime.Now.Ticks; //시작 시간 알아보기 for (int y = 0; y &lt; 10000; y++) { for (int x = 0; x &lt; 10000; x++) arr[x, y] = 1; } long end = DateTime.Now.Ticks; //끝난 시간 알아보기 Console.WriteLine($\"(x,y) 순서 걸린시간 : {end - start}\"); } } 전역 변수로 2차배열 선언 같은 횟수의 반복문 사용하여 2차배열에 값 넣기 같은 횟수의 반복문 사용하여 2차배열에 값 넣기 스코프를 { }로 나눠서 같은 이름의 변수 사용 가능하게 만듦 DateTime.Now.Ticks; 의 start와 end를 빼서 ⇒ 걸리는 시간을 추출 new int[10000, 10000] : 어마어마하게 큰 크기의 2차배열 2중 반복문에서 각각 y,x 순서만 다르게 값을 1로 초기화결과)(y,x) 순서 걸린시간 : 2196603(x,y) 순서 걸린시간 : 3814860 거의 2배 차이!⁉️ 😒왜 두 경우가 같은 시간이 걸리지 않은걸까?이렇게 나오게 된 이유 :(y,x) 순서로 열 ⇒ 행 으로 진행하는 것이메모리 공간 상 인접한 곳에 있는 정보를 등록해놓는캐시의 이점을 활용했기 때문에 더 빠르다 ✨ 2차 배열은 메모리 공간 상1행: [][][][][][] 2행: [][][][][][] 3행: [][][][][][] … 이런 식으로존재 &amp;접근 (x.y) 순서의 행⇒열 접근은메모리 공간 상 띄엄띄엄 있는 곳을 접근했기 때문에 캐시의 이점을 활용하지 못했다1행: [][][][][][] 2행: [][][][][][] 3행: [][][][][][] 이런 식으로 존재1행: [] … 2행: [] … 3행: [] … 이런 식으로 접근" }, { "title": "6강 컴파일러 최적화", "url": "/posts/6%EA%B0%95-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EC%B5%9C%EC%A0%81%ED%99%94/", "categories": "GameServer", "tags": "GameServer", "date": "2022-04-18 00:00:00 +0900", "snippet": "6강 컴파일러 최적화[1] 여러 스레드에서 전역 변수 접근하기program.cs 에서 다음 코딩namespace ServerCore{ class Program { //[2강] static bool _stop = false; static void ThreadMain() { Console.WriteLine(\"스레드 시작\"); while(_stop == false) { // 어디선가 stop 신호를 해주길 기다린다 } } static void Main(string[] args) { Task t = new Task(ThreadMain); t.Start(); Thread.Sleep(1000); //1000ms = 1초 / Main 스레드가 1초동안 슬립했다가 깬다 _stop = true; //=&gt; ThreadMain이 스레드의 _stop bool값이 true가 되었으므로 스레드가 멈출 것임 Console.WriteLine(\"Stop 호출\"); Console.WriteLine(\"종료 대기중\"); t.Wait(); //task는 join과 같은 역할 함 Console.WriteLine(\"종료 성공\"); } }} static bool _stop = false; 전역 변수 Main 스레드에서 _stop bool값을 true로 만들어주어ThreadMain 이 멈춤 동작하는 코드 t.Wait(); //task는 join과 같은 역할 함 백그라운드 실행을 종료 대기함 결과스레드 시작Stop 호출종료 대기중종료 성공D:\\GitRepo\\MyGameServer\\Server\\ServerCore\\bin\\Debug\\netcoreapp3.1\\ServerCore.exe(프로세스 9548개)이(가) 종료되었습니다( 코드: 0개).디버깅이 중지될 때 콘솔을 자동으로 닫으려면 [도구] -&gt; [옵션] -&gt; [디버깅] &gt; [디버깅이 중지되면 자동으로 콘솔 닫기]를 사용하도록 설정합니다.이 창을 닫으려면 아무 키나 누르세요...그러나 이는 Debug 모드 한정이다.실제로 게임이 Release 모드로 바뀌어지면 최적화가 되어지면서ThreadMain이 종료가 되지 않는다 ✨[1] Release 모드결과스레드 시작Stop 호출종료 대기중 종료되지 않고 계속 실행되는 모습 …왜 문제가 일어나는가?! ⇒ 최적화 때문!✨여기서 디스 어셈블리 (디버그 - 창 - 디스어셈블리) 를 디버깅 모드에서 열어보면 while문 안쪽에서 ecx레지스터의 값이 0이면. je (jump Equal) : 값이 0이면 while문 처음으로 실행을 돌아가겠다 = while문 반복문을 돌겠다는 코드로 알아서 최적화가 된 것이다 즉,while(_stop == false){}이 코드가if(_stop == false){\twhile(true){}}로 바뀌어 한번 _stop가 false 이면, 영원히 반복문을 돌게 되는 것이다[2] Release 모드 - 전역변수 최적화 문제 예방하기volatile static bool _stop = false; //전역 변수 선언 시 volatile 키워드를 붙여주게 되면, 최적화 하지 말고 그대로 쓰라는 의미가 된다⇒ 결과) 정상 작동한다 ![3] c++에서 volatile 키워드🔥 혼동하지 말자!   c# c++ volatile [1] 최적화 하지 말라 [2] 캐시를 무시하고, 값을 최신으로 가져와라 [1] 최적화 하지 말라 C#에서 volatile 키워드는 [2] 등을 이유로, 복잡하게 작동하기 때문에, 얘 보다는 다른 키워드를 사용하는 것이 낫다!" }, { "title": "코테 스터디 1-10번 문제 풀이", "url": "/posts/1-10%EB%AC%B8%EC%A0%9C-%EC%A0%95%EB%A6%AC/", "categories": "CodingTestStudy", "tags": "CodingTestStudy", "date": "2022-04-18 00:00:00 +0900", "snippet": "코테 스터디 1-10번 문제 풀이[0] 진약수진약수 갯수 구하기 진약수 : 자기 자신을 뺀 약수들[1] 최대, 최소값min, max 값 구할 때 팁int형의 가장 작은 수 : -214000000int형의 가장 큰 수: 214000000//최소값, 최대값 구하기\tfor(i=1; i&lt;=n; i++){\t\tcin&gt;&gt;a; //cin : enter 치거나 space로 구분하거나 같음 \t\tif(a&gt;max){\t\t\tmax=a;\t\t}\t\tif(a&lt;min){\t\t\tmin=a;\t\t}\t}[2] freopen()input값들을 txt파일에 미리 저장해놓고 쓰는 법freopen(”[텍스트파일명.txt]”,”rt”, stdin); 복잡한 input값들을 미리 정해놓고 긁어다가 활용할 수 있다 파일을 읽어와서 stdin 표준입력에 대한 포인터로 전달한다[3] cin과 scanfcin 과 scanf cin : enter을 치거나 space로 구분하는 것이랑 같음! scanf 도 같음!= ✨ 한줄로 입력 값들을 쭉 칠 수 있음![4] 주민등록번호로 나이 계산주민 등록 번호로 나이 계산하기[1] 나이 계산 기본[뒷자리 첫번째 글자] 여자 2 : ~1999년생 4 : 2000년생 ~ 남자 1 : ~1999년생 3 : 2000년생 ~ [2] 아스키코드와 숫자 🔥주민등록의 경우에는 문자열로 받아서 숫자로 계산해야 한다 암기하면 편하다 문자 아스키코드 ‘0’ 48 [3] 나이 계산 알고리즘 if [1] ~1999년생과 [2] 2000년생 ~ 으로 나눈다 year 출생 년도를 만든다 (98xxxx → 1998) age 현재 년도 기준 - 출생년도 + 1 을 하여 나이를 구한다\t//[1] 나이 계산하기\t//1)19xx년생 일때 2)20xx년생 일때로 구분하여 나이를 구한다\t//** 아스키코드 48 = '0' **\tif(a[7]=='1' || a[7]=='2')\t\tyear = 1900 + (a[0]-48)*10 + (a[1]-48);\telse\t\tyear = 2000 + (a[0]-48)*10 + (a[1]-48);\tage = 2022-year+1; //연도 기준 2022[5] 문자열 관련 1[1]문자열 구하는 함수 쓰지 않고 반복문 돌리기 문자열 끝에는 ‘\\0’ : NULL 문자가 들어감 🌟 ! 이를 이용하여 반복문을 돌리자 \t//a[i] != '\\0' 의 의미: 문자열의 끝을 알리는 문자 = \\0\tfor(i =0; a[i] != '\\0';i++){\t}[2]문자열 아스키 코드로 숫자 구분하기48 = ‘0’ ~ 57 = ‘9’숫자 구하기‘문자’ - 48//아스키 코드로 0부터 9까지의 숫자 문자if(a[i] &gt;= 48 &amp;&amp; a[i] &lt;= 57){ }[6] 문자열 관련 2[1]대문자에서 소문자 구하기대문자 문자 + 32[2]공백 (스페이스 입력)을 포함하여 문자열 읽기 scanf 나 cin 을 사용하면 공백 (스페이스)를 입력 (엔터처리)하여 값이 들어간다⇒ gets([주소]) 를 사용하면, 공백을 포함하여 한줄 통으로 문자열 값으로 쳐진다#include &lt;iostream&gt;//영어 단어 복구// 문자열의 공백을 제거하고, 소문자로 변경시켜 출력하라\t//bE au T I fu L =&gt; beautiful 로 바꿔서 출력!/* run this program using the console pauser or add your own getch, system(\"pause\") or input loop */int main(int argc, char** argv) {\tchar a[101], b[101];\tint i, pos=0;\t//* 중요 함수 ! *\tgets(a); //공백, 스페이스 상관없이 한줄 읽어버림\tfor(i =0; a[i] != '\\0'; i++){\t\tif(a[i] != ' '){ //[1] 공백이 아닐 때\t\t\tif(a[i] &gt;= 65 &amp;&amp; a[i] &lt;= 90){\t\t\t\tb[pos++] = a[i] + 32;\t\t\t\t//아스키코드 상 대문자에서 소문자로 변하기 +32를 하면 소문자로 변함\t\t\t}\t\t\telse b[pos++] = a[i];\t\t}\t}\tb[pos] = '\\0';\tprintf(\"%s\\n\",b);\treturn 0;}[7] 스택 안 쓰고, 괄호 검사하기[1]괄호 검사하기 스택 안 쓰고 풀기 꼼수! 괄호를 if 문으로 각각 여는괄호 +1, 닫는괄호 -1로 설정한다 거짓 증상 닫는 괄호가 더 많은 경우 위 값의 합이 중간에 음수가 나온다 사유 : 닫는 괄호가 제대로 나오면 무조건 0이다 반복문으로 다 검사 후 합 값이 음수이다 참 증상 모두 검사했지만 위 경우들에 해당하지 않는다 #include &lt;iostream&gt;//올바른 괄호//괄호가 입력되는데, 올바르면 YES, 올바르지 않으면 NO 출력//여는 괄호가 있는데 닫는 괄호가 없으면 올바르지 않은 것임// [스택 미사용 방법]// 괄호 당 1 로 값을 할당하고, 닫는 괄호는 -1 음수로 할당한다 =&gt; 최종 값이 0 이 아니면 거짓! int main(int argc, char** argv) {\tchar a[101];\tint i, cnt = 0;\tscanf(\"%s\", &amp;a);\tfor(i =0; a[i] != '\\0'; i++){\t\tif(a[i]=='('){\t\t\tcnt += 1;\t\t}\t\telse if(a[i]==')'){\t\t\tcnt -= 1;\t\t}\t\tif(cnt &lt;0) break; //중간에 음수가 나오는 경우는 닫는 괄호가 더 많은 경우이므로 무조건 거짓!\t}\tif(cnt == 0){\t\tprintf(\"YES\\n\");\t}\telse{\t\tprintf(\"NO\\n\");\t}\treturn 0;}[8] 빡센 약수 갯수 구하기N까지의 모든 수의 약수 갯수를 출력하는 문제배수를 이용하여 배수부터 검사하는 방법을 사용하자[1]정석 (빡센 문제에서 타임리미트) 나오는 약수 구하기\t//[1] ================\tint cnt =0;\t//타임리미트 풀이\tfor(i =1; i&lt;=n; i++){\t\tcnt=0;\t\tfor(j=1; j&lt;=i; j++){\t\t\tif(i%j==0){\t\t\t\tcnt++;\t\t\t}\t\t}\t\tprintf(\"%d \",cnt);\t\t\t}[2] 배수 검사로 약수 갯수 구하기#include &lt;iostream&gt;//모두의 약수//*!! 타임리미트 존재 !!*//N을 입력하면 1부터 N까지의 모든 수의 약수의 갯수가 출력되게 하라int cnt[50001]; //n의 크기 제한이 &lt;=50000까지 이므로 50001을 배열 길이로 설정//전역 변수로 배열을 선언하면 값이 0으로 초기화가 된다 !!***//지역 변수로 cnt를 할당하게 되면 값들이 0으로 초기화 되지 않아서 이상한 값이 나오고//50001은 너무 큰 배열이라 스택에 할당하게 되면 값이 제대로 할당되지 않을 수가 있다int main(int argc, char** argv) {\tint n,i,j;\tscanf(\"%i\", &amp;n);\t//[2] =================\t// i가 1일 시 cnt 결과 : \t//cnt [1] [1] [1] [1] [1] [1] [1] [1] [1] ... [1]\t//배수로 약수를 구하는 풀이\t//int cnt[50001];\tfor(i=1; i&lt;=n; i++){\t\tfor(j=i; j&lt;=n; j=j+i){//i의 배수로 약수를 증가시키기\t\t\tcnt[j]++; //j는 i의 배수 이므로 약수 개수 1 추가됨 !\t\t}\t\t//printf(\"%d \",cnt[i]);\t}\tfor(i=1; i&lt;=n; i++){\t\tprintf(\"%d \", cnt[i]);\t}\treturn 0;}[9] 전역 변수 선언 지역 변수 선언을 하면 문제가 틀리는 문제가 있다 이유: 지역 변수는 선언만으로는 초기화가 안 된다 ↔ 전역 변수 선언은 선언만으로 배열, 변수 값이 0으로 초기화 된다 지역 변수는 스택 영역에서 만들어지며, 이 공간이 충분히 크지 않기 때문에 들어가는 값이 너무 크면 이상한 값이 될 수가 있다 ⇒ 전역변수로 선언하자! int cnt[50001]; //n의 크기 제한이 &lt;=50000까지 이므로 50001을 배열 길이로 설정//전역 변수로 배열을 선언하면 값이 0으로 초기화가 된다 !!***//지역 변수로 cnt를 할당하게 되면 값들이 0으로 초기화 되지 않아서 이상한 값이 나오고//50001은 너무 큰 배열이라 스택에 할당하게 되면 값이 제대로 할당되지 않을 수가 있다int main(int argc, char** argv) {\t...}[10] 자릿수의 구하기자릿수 구하기 어떤수 X를 10으로 나눈 나머지 = 제일 오른쪽 자릿수 어떤수 X를 10으로 나눈 몫 = 제일 오른쪽 자릿수를 뺀 수 123 / 10 → 12 어떤수 X를 계속 10으로 나눠서 0이 나누면 다 나눈 것이다 100 → (1) 100/10, (2) 10/10, (3) 1/10 = 0 : 다 나눈 것 #include &lt;iostream&gt; //자릿수의 합 //N개의 자연수가 입력 되면 각 자연수의 자릿수의 합을 구하고, //그 자릿수의 합이 최대인 자연수를 출력하라 //자연수의 자릿수를 구하는 함수는 int digit_sum(int x) 를 작성하라 //자릿수 구하기 int digit_sum(int x){ \tint tmp, sum = 0 ; \t//!!**중요**!! \t//자릿수 구하기 (제일 오른쪽 자릿수 -&gt; 왼쪽 자릿수를 더해가는 식) \twhile(x&gt;0){ \t\ttmp = x%10; // 10으로 나눈 나머지 : 제일 끝자리 수 출력 \t\tx /= 10; // = 제일 끝자리를 뺀 수 ... 8ㅅ8 \t\tsum += tmp; \t} " }, { "title": "3강 환경설정", "url": "/posts/%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95/", "categories": "GameServer", "tags": "GameServer", "date": "2022-04-17 00:00:00 +0900", "snippet": "3강 환경설정서버 폴더 만들어서 .Net core로 콘솔앱 프로젝트 만들기 그 이전에는 비주얼스튜디오 인스톨에서 .Net core 플랫폼간 개발을 설치⇒ 그폴더 안에 또 새로운 프로젝트 만들기 추가 하기 2번 Server : 서버 기능을 하는 부분 ServerCore : 서버의 핵심적인 부분 코드가 있을 예정 DummyClinet : 서버 이용하는 손님 역할 테스트할 때 필요 여러가지 프로젝트를 한번에 실행하기프로젝트 - 속성 - 여러가지 실행하기 (?) 여기서 동시에 실행하고자 하는 프로젝트를 [시작]으로 놓으면 된다그 후에 Ctrl + F5 누르기" }, { "title": "2강 게임서버 개론", "url": "/posts/%EC%84%9C%EB%B2%84-%EA%B0%9C%EB%A1%A0/", "categories": "GameServer", "tags": "GameServer", "date": "2022-04-17 00:00:00 +0900", "snippet": "※ 1강은 OT입니다2강 게임서버 개론 서버란 무엇인가 다른 컴퓨터에서 연결이 가능하도록 대기 상태로 상시 실행중인 프로그램 손님이 올수 있도록 식당을 열고 대기중인 영업중인 식당과 비슷하다게임 서버의 종류(1) 웹서버 : = HTTP Server 손님이 음식을 받아서 떠나면 그 후로 연락이 끊기는 테이크아웃 맥도날드라고 생각하면 된다 질의 응답 형태로 진행된다(2) 게임 서버 = TCP Server, Binary Server, Stateful Server 일반 식당 실시간 Interaction이 있다 교류가 더 중요하게 작용된다웹서버 Web Server 드물게 정보를 요청, 갱신한다 실시간 Interaction이 필요하지 않다 식당에서 손님에게 먼저 접근할 일은 없다 랭킹 시스템만 있는 게임이 이 경우로 쓰인다 클래시 오브 클랜즈같은 게임 - 개인적으로 게임을 하고 랭킹정도만 모아보는 정도 (해봐야지)웹서버의 제작 구글, 아마존, 네이버 등등 단순히 게임에 국한되지 않음, 웹서비스 만드는데 사용된다 처음부터 만드는 경우는 거의 없고, 프레임 워크를 하나 골라서 사용한다게임 서버 요청, 갱신 횟수가 많다 실시간 Interaction이 필요하다 직원이 손님에게 접근 가능해야한다 손님의 상태를 보며 서비스를 제공한다 (Stateful) 예시) 스타크래프트, 워크래프트 게임, 장르에 따라 요구사항이 다르다 ⇒ 최적의 프레임워크가 거의 없다게임 서버의 제작은식당으로 비유해보기 손님 한도 : 최대 동시 접속자 한방에 들어갈 수 있는 손님의 일행 한도 : 게임 장르 및 채널링 직원 역할 구분, 겸직이 가능한지 : 게임 로직, 네트워크, DB 직원은 몇명을 둘지 : 쓰레드 개수 요리사, 서빙, 결제 직원 비율을 어떻게 할지 : 쓰레드 모델 주문은 어떻게 반들지 : 네트워크 모델 손님이 기다릴 수 있는 시간 한도 : 반응성 ( FPS, MMORPG ) 장부 및 결제는 어떻게 할지 : 데이터베이스" }, { "title": "4강 멀티 스레드 개론", "url": "/posts/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C-%EA%B0%9C%EB%A1%A0/", "categories": "GameServer", "tags": "GameServer", "date": "2022-04-17 00:00:00 +0900", "snippet": "4강 멀티 스레드 개론멀티 스레드스토리 텔링으로 설명…🍴 고급 레스토랑 = 프로세스 (프로그램)🧑 로봇직원 = 쓰레드💙 식당 관리자 영혼 = 프로세서 (cpu 코어), 운영체제 (windows 커널 모드)에서 동작🍴 고급 레스토랑 한식, - 사람, 주방, 계산대, 테이블 일식, - 사람, 주방, 계산대, 테이블 패밀리 레스토랑 - 사람2인, 주방, 계산대, 테이블🧑 식당 관리자 1인 사람은 💙 식당 관리자의 영혼이 깃들어 움직이는 로봇 아주 짧은 시간을 텀으로 모든 사람들에게 빙의하며 일을 함 ⇒ 3개의 식당이 정상 운영함하나의 CPU를 성능 좋게 만들기에는 한계가 있기 때문에, 여러 개의 CPU를 만드는 방향으로 여러 직원을 움직이게 할 수 있다 ⇒ 더 빠르게 동작 그러나, 빙의 자체가 많은 자원을 필요로 하는 작업이기 때문에 무작정 스레드를 들린다고 해서 좋은 것은 아니다 이상적인 상황: 코어 수(사람 수) 만큼 🧑 스레드가 존재하는 상황 스레드 관리가 안 되는 순간, 난장판이 될 것 기아 현상한쪽에 CPU 작업을 몰빵해주어서 전체 프로그램들이 잘 작동되지 않는 현상" }, { "title": "5강 쓰레드 생성", "url": "/posts/5%EA%B0%95-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%83%9D%EC%84%B1/", "categories": "GameServer", "tags": "GameServer", "date": "2022-04-17 00:00:00 +0900", "snippet": "5강 쓰레드 생성ServerCore 파일의 Program.cs (중요) 에서다음 코딩using System;using System.Threading;namespace ServerCore{ class Program { static void MainThread() { Console.WriteLine(\"Hello Thread!\"); } static void Main(string[] args) { Thread t = new Thread(MainThread); //MainThread 스레드 생성 (서브 직원) t.Start(); //일을 하라고 명령. (스레드 실행) Console.WriteLine(\"Hello Main!\"); } }}C#의 스레드는 기본적으로 앞에서 실행되게 만들어진다 (폴 그라운드) ↔ 백그라운드t.IsBackground = true;백그라운드 실행static void MainThread() { while(true) Console.WriteLine(\"Hello Thread!\"); }static void Main(string[] args) { Thread t = new Thread(MainThread); //MainThread 스레드 생성 (서브 직원) t.IsBackground = true; t.Start(); //일을 하라고 명령. (스레드 실행) Console.WriteLine(\"Hello Main!\"); } 다음과 같다면 백그라운드 실행 스레드는 폴그라운드 실행 스레드가 끝나면 자동 종료됨백그라운드 실행 종료 대기하기Console.WriteLine(\"Waiting for Thread!\");t.Join();스레드 이름 설정t.Name = \"Test Background Thread\";다음과 같이 확인 가능)스레드풀링 (단기알바 고용)static void MainThread(object state) { for(int i=0; i&lt;5; i++) Console.WriteLine(\"Hello Thread!\"); }static void Main(string[] args) { ThreadPool.QueueUserWorkItem(MainThread);//단기알바 모집 //백그라운드로 돌아가는 스레드 while (true) { } } 결과: 스레드 업무를 다 실행한 다음 종료되지 않고 지속원리이미 스레드들이 마련되어있음 (직원 고용이 완료) ⇒ 스레드 대기소에서 대기중인 상태스레드의 할일 실행 ⇒ 스레드의 할일이 끝나면, 다시 스레드 대기소 들어가서 대기함주의 점기존에 있던 풀에서 활용을 하는 것이므로, 풀에 비해서 일감이 많을 시먹통이 될 수가 있다 (예- 무한루프 일감)= 기존 인력이 돌아오지 않는 경우cf) 오브젝트 풀링오브젝트를 풀에 대기시켰다가 필요할때가 되면 재사용함이와 같은 원리임스레드가 너~무 많을 시for (int i = 0; i &lt; 1000; i++) { Thread t = new Thread(MainThread); //MainThread 스레드 생성 (서브 직원) //t.Name = \"Test Background Thread\"; t.IsBackground = true; t.Start(); //일을 하라고 명령. (스레드 실행) } 1000개의 스레드를 만들어서 일을 시키는 중어떨까?스레드를 생성해서 일을 시키는 일이스레드가 실제로 해야 할 일을 하는 것보다 오랜 시간이 걸릴 것 ⇒ 🤮최악!영영 돌아오지 않는 스레드일감 (hello thread 5번 출력)static void MainThread(object state) { for(int i=0; i&lt;5; i++) Console.WriteLine(\"Hello Thread!\"); }스레드 인력 사무소static void Main(string[] args) { ThreadPool.SetMinThreads(1, 1); //최소 스레드 1개 ThreadPool.SetMaxThreads(5, 5); //최대 스레그 5개 설정 for (int i = 0; i &lt; 5; i++) { //obj를 받아서 무한루프를 실행하도록 해줌 ThreadPool.QueueUserWorkItem((obj)=&gt; { while (true) { } }); } ThreadPool.QueueUserWorkItem(MainThread);//단기알바 모집 //일감 (hello thread 5번 출력)\t\t\t\t}해석for (int i = 0; i &lt; 5; i++) { //obj를 받아서 무한루프를 실행하도록 해줌 ThreadPool.QueueUserWorkItem((obj)=&gt; { while (true) { } }); }스레드가 5개가 존재함.이 부분에서 5개의 스레드가 무한 루프를 돌고있어 남는 스레드가 없으므로 일감을 수행할 스레드가 없어서 먹통이 된다Task ⇒ 스레드의 먹통 단점 극복결과: 먹통이 되는 일감이 있어도, MainThread 일들을 일단 처리하게 될 것Task t = new Task(() =&gt; { while (true) { } }, TaskCreationOptions.LongRunning); //오래 걸리는 작업임을 알려줌t.Start();Task직원이 할 일감 단위를 정해줌스레드 풀에 넣어져서 관리하게 활용할 것옵션 설명🔥TaskCreationOptions.LongRunning : 오래 걸리는 일감임을 알려줌 이 기능으로 먹통이 될 일이 없게 된다 (이 옵션이 없다면 다시 먹통이 됨)static void MainThread(object state){ for(int i=0; i&lt;5; i++) Console.WriteLine(\"Hello Thread!\");}static void Main(string[] args){\tThreadPool.SetMinThreads(1, 1); ThreadPool.SetMaxThreads(5, 5); for (int i = 0; i &lt; 5; i++) {\t //오래 걸리는 작업임을 알려줌 Task t = new Task(() =&gt; { while (true) { } }, TaskCreationOptions.LongRunning); t.Start(); }}* 람다 식*같은 의미이다static void MainThread(object state){\twhile(true) {}}static void Main(string[] args){\tThreadPool.QueueUserWorkItem(MainThread);//단기알바 모집}object 형식으로 state를 인자로 받는 것== (obj)=&gt; { while (true) { } }static void Main(string[] args){\tThreadPool.QueueUserWorkItem((obj)=&gt; { while (true) { } });}인자가 없는 람다 식() =&gt; { while (true) { } })" }, { "title": "4강 프로젝트 세팅", "url": "/posts/4%EA%B0%95-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%84%B8%ED%8C%85/", "categories": "DirectX12", "tags": "DirectX12", "date": "2022-04-17 00:00:00 +0900", "snippet": "4강 프로젝트 설정프로젝트 만들기 &amp; 설정하기[1]프로젝트 생성 - C++ 언어 설정 - Window 데스크탑 애플리케이션 프로젝트 만들기 - 정적 라이브러리 타입의 프로젝트 추가 (이름은 Engine) 필터 추가 (Engine, Resource, Utils) - 한글 폴더 제거 - Utils필터에 소스코드들 추가 - Engine.cpp 제거 (필요 없다)DLL(동적 라이브러리)와 정적 라이브러리의 차이점DLL : 런타임에 연결되는 라이브러리정적 라이브러리 : 소스 코드를 빌드할때 포함되어 연결되는 라이브러리라이브러리(엔진)을 분리하는 이유클라이언트 (컨텐츠 부분) 과 엔진 부분을 나누기 위함이다빌드 시 엮여있는 상황이 될 것. 예시로 엔진 수정 시 클라이언트까지 빌드를 해야 함 ⇒ 최악🤮[2] Engine 프로젝트의 특징 메인 함수가 없다 기능 모음집 (=라이브러리) 이기 때문이다 다음을 pch.h (프리 컴파일된 헤더) 에 코딩하고 framework.h 제거// framework.h의 유일한 한줄 코드입니다#define WIN32_LEAN_AND_MEAN // 거의 사용되지 않는 내용을 Windows 헤더에서 제외합니다.(결과) - pch.h#ifndef PCH_H#define PCH_H#define WIN32_LEAN_AND_MEAN // 거의 사용되지 않는 내용을 Windows 헤더에서 제외합니다.#endif //PCH_H Utils 에 클래스 추가 (EnginePch) EnginePch.h 에 다음 코딩 (앞으로 사용하게 될 라이브러리들)#pragma once// 각종 include#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;array&gt;#include &lt;list&gt;#include &lt;map&gt;using namespace std;#include \"d3dx12.h\"#include &lt;d3d12.h&gt;#include &lt;wrl.h&gt;#include &lt;d3dcompiler.h&gt;#include &lt;dxgi.h&gt;#include &lt;DirectXMath.h&gt;#include &lt;DirectXPackedVector.h&gt;#include &lt;DirectXColors.h&gt;using namespace DirectX;using namespace DirectX::PackedVector;using namespace Microsoft::WRL;// 각종 lib (라이브러리)#pragma comment(lib, \"d3d12\")#pragma comment(lib, \"dxgi\")#pragma comment(lib, \"dxguid\")#pragma comment(lib, \"d3dcompiler\")// 각종 typedef 오른쪽의 형을 왼쪽으로 사용할 수 있게 함using int8\t\t= __int8;using int16\t\t= __int16;using int32\t\t= __int32;using int64\t\t= __int64;using uint8\t\t= unsigned __int8;using uint16\t= unsigned __int16;using uint32\t= unsigned __int32;using uint64\t= unsigned __int64;using Vec2\t\t= XMFLOAT2;using Vec3\t\t= XMFLOAT3;using Vec4\t\t= XMFLOAT4;using Matrix\t= XMMATRIX;void HelloEngine();내용 중 #include \"d3dx12.h\"이 파일은 없음! 마이크로소프트 d3dx12.h파일 깃허브이 곳에서 직접 다운 받아서 프로젝트에 넣어야 함 ! 마이크로 소프트에서 지원해주는 비 공식적 유틸리티 라이브러리 편리하게 이용할 수 있는 기능들이 모여있음이제 Engine.cpp 안의 다음 HelloEngine()을 클라이언트에서 부를 수 있게 할 것#include \"pch.h\"#include \"EnginePch.h\"void HelloEngine(){} pch.h 에 다음 추가#include \"EnginePch.h\" EnginePch.h은 공용 헤더로써, 나중에 클라이언트에서 EnginePch.h 을 사용하기 위해서 따로 분리를 하였다빌드해보기빌드를 하면 프로젝트 폴더의 x64 - Debug 폴더 안에 내용물이 만들어진다. Engine.lib 파일 후에 이 파일을 클라이언트에서 사용하게 된다 Client.exe 파일은 실행할 수 있지만, Engine파일은 그렇지 않음. 차이가 있다[2]Client 설정Client 프로젝트 (우클릭) 속성에서 다음과 같이 설정 미리 컴파일된 헤더 - 사용 설정, pch.h 를 미리 컴파일된 헤더 파일로 설정 플랫폼을 x64로 설정 Client (우클릭) 클래스 추가 - pch 클래스 추가 Client 필터 추가 Game, Utils - Utils 에 모든 소스코드 넣기 - 헤더파일 폴더 삭제생성한 pch.cpp 에서 속성 페이지 - c/c++ 설정 - 미리컴파일된 헤더 : 만들기 설정앞으로 생성할 cpp 파일들에서 다음 헤더를 가장 상위에 추가 해야 함 안 하면 에러가 난다#include \"pch.h\"[3] pch.h 설명#pragma once#pragma comment(lib, \"Engine.lib\")#include \"EnginePch.h\"#include \"EnginePch.h\" 에서 에러가 나는 이유 🔥🔥🔥 Engine 폴더와 Client 폴더의 경로가 다르기 때문 ⇒ 경로를 설정해 주어야 한다![4] 빌드 결과물이 (x64 폴더 말고) 다른 폴더에 만들어지게 할 때, 사전 세팅원하는 프로젝트 ( 여기선 Engine 프로젝트) - 속성 - 구성 속성 - 일반 - 출력 디렉터리다음과 같이 설정$(SolutionDir)[폴더명]\\이렇게 하면 빌드 후 [폴더명] 에 Engine 프로젝트 빌드 결과가 저장이 된다[5] 클라이언트에서 Engine 의 코드들을 사용하기클라이언트에서 Engine 의 코드들을 사용하기⇒ 엔진의 [1] 헤더 파일들의 경로와 [2] 라이브러리 파일의 경로 [3] 사용할 파일들의 경로를 알려주어야 함[1] Client 속성 - C/C++ 일반 - 추가 포함 디렉터리 $(SolutionDir)Engine\\[2] Client 속성 - 링커 - 일반 - 추가 라이브러리 디렉터리 $(SolutionDir)Output\\ 위 [4]단계에서 빌드 결과물이 있는 폴더 명을 써야 함 [3] 사용할 파일들을 알려주기pch.h 에 #include \"EnginePch.h\" 윗줄에 다음 코딩#pragma comment(lib, “Engine.lib”) 전처리기 단계에서 빌드하기 전에 “Engine.lib” 파일을 사용할 것을 요청함⇒ 이 단계까지 끝나면 [3] pch.h 설명에서 났던 에러가 사라진다! 🔥🔥🔥클라이언트에서 Engine 의 함수 사용하기 기능 추가는 X[1]Game 폴더 - 추가 클래스 - Game 클래스 추가여기서 만들었던 Game.cpp 파일에 다음과 같이 코딩 ⇒ 엔진에 있던 함수를 호출하게 만들어보자🔽 Game.cpp#include \"pch.h\"#include \"Game.h\"void Game::Init(){\tHelloEngine();}void Game::Update(){} HelloEngine(); : Engine.cpp 에 있던 함수이다 ! ✨[2]Client.cpp 파일에서 wWinMain메인 함수 안에서 다음과 같이 무한루프를 돌며 기능을 수행 중이다(라고 까지만 대강 알고 있자)while (GetMessage(&amp;msg, nullptr, 0, 0)) { if (PeekMessage(&amp;msg, nullptr, 0, 0, PM_REMOVE)) { if (msg.message == WM_QUIT) break;\t\t\tif (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))\t\t\t{\t\t\t\tTranslateMessage(&amp;msg);\t\t\t\tDispatchMessage(&amp;msg);\t\t\t} }\t\t// TODO game-&gt;Update(); }🔼 무한 루프문Game 클래스 내용을 메인함수 wWinMain에서 호출하기⇒ 다음을 wWinMain 의 while 무한루프 위에 코딩unique_ptr&lt;Game&gt; game = make_unique&lt;Game&gt;(); //Game 클래스 만들기game-&gt;Init(); //초기화 시키기다음을 wWinMain 의 while 무한루프 안에 코딩game-&gt;Update(); //갱신하기 Game 이 while 문이 도는 주기 (프레임) 만큼 갱신이 된다[3]while (GetMessage(&amp;msg, nullptr, 0, 0)) {\tif (PeekMessage(&amp;msg, nullptr, 0, 0, PM_REMOVE))\t...}다음은 마우스나 키보드의 입력 등 이벤트가 있을 시 GetMessage로 깨어나서 while문을 돌겠다는 의미이다 …⇒ 그런 이벤트 없이, 이벤트 메시지가 있건 없건 실행되어야 하기 때문에 다음과 같이 코딩한다완성된 메인함수의 while 문while (true) { if (PeekMessage(&amp;msg, nullptr, 0, 0, PM_REMOVE)) { if (msg.message == WM_QUIT) break;\t\t\tif (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))\t\t\t{\t\t\t\tTranslateMessage(&amp;msg);\t\t\t\tDispatchMessage(&amp;msg);\t\t\t} }\t\t// TODO game-&gt;Update(); } 스마트 포인터 사용unique_ptr&lt;Game&gt; game = make_unique&lt;Game&gt;();파일, 도움말 메뉴 뜨지 않게 하기여기까지 과정을 실행하면 다음과 같이 파일, 도움말 메뉴가 달린 Client 가 실행된다이를 없애보자 Client.cpp 에서 MyRegisterClass 부근의 wcex.lpszMenuName 값을 바꿔준다wcex.lpszMenuName = nullptr;결과) 파일, 도움말 메뉴가 사라져 말끔해진 Client.exe 실행 결과" }, { "title": "1강~3강 랜더링 파이프라인OT", "url": "/posts/1%EA%B0%95~3%EA%B0%95-%EB%9E%9C%EB%8D%94%EB%A7%81-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8OT/", "categories": "DirectX12", "tags": "DirectX12", "date": "2022-04-17 00:00:00 +0900", "snippet": "1강~3강 랜더링 파이프라인OT✨1강 OT동기 부여[1]회사는 다양한 직군을 잘 아는 개발자를 원한다실무 면접에서 다음과 같은 내용의 질문이 많다랜더링에 대해 배우는 것이 면접 공부에도 도움이 될 것 랜더링 파이프라인 Diffuse, Ambient, Specular Double Buffering Tangent Space 그림자 원리 짐벌락 현상 Quaternion공부 방식자세한 것 하나하나보다는 전체 숲을 보면서 공부하는 식의 공부를 추천✨2강 그래픽스 OT영화 촬영과 비교하기 영화 촬영 무대 조명 = 게임의 조명 배우 = 게임의 오브젝트 카메라 = 게임의 카메라 카메라로 촬영한 결과물 = 게임의 장면영화 감독이 할 일 ⇒ 위 조건에서 대사, 카메라맨 조정, 조명 조절그래픽스[1]게임의 화면 구성 ⇒ 픽셀로 이루어져 있다[2]애니메이션과 게임의 비교애니메이션 : 고정된 카메라로 딱 한번만 *한 장면만 표현(계산)하면 끝↔게임 : 실시간 랜더링, 고정되지 않은 카메라 (플레이어의 이동에 따라 카메라가 변화)DirectXDirectX 로 할 일 : 촬영 무대와 게임 오브젝트를 이용해 게임 화면을 (보이도록) 구성하는 것 3D 환경을 2D 화면으로 그려주는 일✨3강 랜더링 파이프라인 OT모든 물체들은 삼각형 단위로 그려져있다 확인해보기 유니티의 뷰포트에서 Shaded → Wireframe 모드로 게임 화면을 보면 큐브 하나가 삼각형들로 이루어져 있다 🔼 와이어프레임 모드에서 삼각형으로 표현되는 큐브현대 게임에서 CPU의 역할 고전 게임에서 정점 갯수가 얼마 없는 캐릭터는 가능했지만 요즘 게임에서는 불가하다고 보면 됩니다GPU와 랜더링 파이프 라인CPU와 GPU의 구조 차이CPU : ALU가 그닥 없음 서로 연관이 있는 복잡한 연산 위주 =고급 인력GPU : 대부분 영역을 ALU가 차지함 (단순 연산을 하는 ALU) 서로 연관성이 없는 단순 연산 위주 = 외주 인력 마이크로소프트와 협력하여, DirectX 스펙에 맞춰 제품을 만든다DirectX : 마이크로소프트에서 제공하는 GPU 외주 라이브러리랜더링 파이프 라인 한눈에 보기Input Assembler Stage : 정점 정보를 전달하기 (물체를 구성하는)Vertex Shader Stage : 정점 관련 연산, 정점 변환 (정점 이동 등)Tessellation Stage : 새로운 정점들을 생성, 멀리있는, 가까운 물체들을 서로 다르게 표현하기, 주로 지형 단위 위주 Hull Shader Stage Tessellator Stage Domain Shader StageGeometry Shader Stage : 새로운 정점들을 생성, 작은 규모의 삼각형 단위 위주( Stream Output Stage )Rasterizer Stage : 정점 데이터를 기반으로 픽셀 단위로 표현한다. 삼각형 단위의 색상을 보간하는 작업 등을 한다Pixel Shader Stage : 최종적으로 픽셀에 생상을 입히는 단계Output-Merger Stage : 마무리로 윗단계들의 결과들을 바탕으로 색상을 표현하는 단계" }, { "title": "Jekyll 테마 Fork한 블로그 잔디 심기", "url": "/posts/Jekyll-%ED%85%8C%EB%A7%88-Fork%ED%95%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%8F%AC%EC%8A%A4%ED%8C%85-%EC%9E%94%EB%94%94-%EB%82%A8%EA%B8%B0%EA%B8%B0/", "categories": "Jekyll", "tags": "Tutorial, Jekyll", "date": "2022-04-05 00:00:00 +0900", "snippet": "Jekyll 테마 fork한 레포지토리 잔디 심기 + 오류 해결나처럼 깃헙 블로그 테마를 원본 레포에서 Fork 하여 사용한 사용자라면 이상할 것이다커밋 푸시를 해도… 깃허브 메인에 잔디가 표시가 안 된다 😅 (저는 Chirpy테마 fork하여 사용 중)이 방법은 왜 되나요bare clone 과 mirror push 로 인해 자신이 (fork하여) 작업하던 레포지토리의 모든 푸시 내역 등의 작업 내역들까지 앞으로 만들 새 레포지토리에 복사가 되는 것이다.방법새 레포지토리 만들기 = A내가 Fork 해서 작업했는데 잔디가 안 심어지는 기존의 레포지토리 = B(주의) A 레포와 B 레포 둘을 헷갈려서 진행하면 끔찍한 결과가 기다린다. 주의하자….cd 명령어로 A,B를 제외한 아무 폴더 경로에 가서git clone --bare https://github.com/HanbiJang/hanbijang.github.io.git와 같이git clone --bare B레포지토리주소입력해주고🔥 cd 명령어로 B 레포지토리 폴더로 가서 (없으면 클론해서 만들어야 한다)git push --mirror A레포지토리주소위 방법으로 하면 됨 (정말 간단함!)그리고 나서🔥 A레포지토리의 Settings 으로 가서 Branch를 내가 작업했던 브랜치로 설정한다! (중요) Chirpy 테마의 경우, 브랜치를 하나 더 만드는 등 다른 짓을 하지 않았다면 master 일 것이다Push가 안 되는 오류그러나!! push 단계에서 뜬금 없이 workflow scope 에러 발생하는 경우가 있음 최근에 깃허브 토큰을 재발급 받았거나 하는 경우가 원인인듯하지만 누구에게나 발생 가능… 내 경우는 master등을 제외한 gh pages 브랜치만 복사되는 문제가 있었다$ git push --mirror https://github.com/HanbiJang/new_repo.gitEnumerating objects: 6437, done.Counting objects: 100% (6437/6437), done.Delta compression using up to 12 threadsCompressing objects: 100% (2773/2773), done.Writing objects: 100% (6350/6350), 5.22 MiB | 4.35 MiB/s, done.Total 6350 (delta 3680), reused 6078 (delta 3467), pack-reused 0remote: Resolving deltas: 100% (3680/3680), completed with 54 local objects.To https://github.com/HanbiJang/new_repo.git ! [remote rejected] main (refusing to delete the current branch: refs/heads/main) ! [remote rejected] master -&gt; master (refusing to allow an OAuth App to create or update workflow `.github/workflows/pages-deploy.yml` without `workflow` scope) ! [remote rejected] origin/HEAD -&gt; origin/HEAD (refusing to allow an OAuth App to create or update workflow `.github/workflows/pages-deploy.yml` without `workflow` scope) ! [remote rejected] origin/code-style-review -&gt; origin/code-style-review (refusing to allow an OAuth App to create or update workflow `.github/workflows/ci.yml` without `workflow` scope) ! [remote rejected] origin/docs -&gt; origin/docs (refusing to allow an OAuth App to create or update workflow `.github/workflows/ci.yml` without `workflow` scope) ! [remote rejected] origin/master -&gt; origin/master (refusing to allow an OAuth App to create or update workflow `.github/workflows/pages-deploy.yml` without `workflow` scope) ! [remote rejected] origin/production -&gt; origin/production (refusing to allow an OAuth App to create or update workflow `.github/workflows/ci.yml` without `workflow` scope) ! [remote rejected] v2.0 -&gt; v2.0 (refusing to allow an OAuth App to create or update workflow `.github/workflows/ci.yml` without `workflow` scope) ! [remote rejected] v2.1 -&gt; v2.1 (refusing to allow an OAuth App to create or update workflow `.github/workflows/ci.yml` without `workflow` scope) ! [remote rejected] v2.2 -&gt; v2.2 (refusing to allow an OAuth App to create or update workflow `.github/workflows/ci.yml` without `workflow` scope) ! [remote rejected] v2.2.1 -&gt; v2.2.1 (refusing to allow an OAuth App to create or update workflow `.github/workflows/ci.yml` without `workflow` scope) ! [remote rejected] v2.3 -&gt; v2.3 (refusing to allow an OAuth App to create or update workflow `.github/workflows/ci.yml` without `workflow` scope) ! [remote rejected] v2.4 -&gt; v2.4 (refusing to allow an OAuth App to create or update workflow `.github/workflows/ci.yml` without `workflow` scope) ! [remote rejected] v2.4.1 -&gt; v2.4.1 (refusing to allow an OAuth App to create or update workflow `.github/workflows/ci.yml` without `workflow` scope) ! [remote rejected] v2.4.2 -&gt; v2.4.2 (refusing to allow an OAuth App to create or update workflow `.github/workflows/ci.yml` without `workflow` scope) ! [remote rejected] v2.5 -&gt; v2.5 (refusing to allow an OAuth App to create or update workflow `.github/workflows/ci.yml` without `workflow` scope) ! [remote rejected] v2.5.1 -&gt; v2.5.1 (refusing to allow an OAuth App to create or update workflow `.github/workflows/ci.yml` without `workflow` scope) ! [remote rejected] v2.6.0 -&gt; v2.6.0 (refusing to allow an OAuth App to create or update workflow `.github/workflows/ci.yml` without `workflow` scope) ! [remote rejected] v2.6.1 -&gt; v2.6.1 (refusing to allow an OAuth App to create or update workflow `.github/workflows/ci.yml` without `workflow` scope) ! [remote rejected] v2.6.2 -&gt; v2.6.2 (refusing to allow an OAuth App to create or update workflow `.github/workflows/ci.yml` without `workflow` scope) ! [remote rejected] v2.7.0 -&gt; v2.7.0 (refusing to allow an OAuth App to create or update workflow `.github/workflows/ci.yml` without `workflow` scope)error: failed to push some refs to 'https://github.com/HanbiJang/new_repo.git'이런 끔찍한 오류가 좌르륵 나온다면자격 증명 관리자 - window 자격증명에서git:[https://github.com](https://github.com/)이 녀석을 지우고 다시 시도하면깃허브 로그인 창이 뜨면서 아래와 같이 해결된다$ git push --mirror https://github.com/HanbiJang/new_repo.gitEnumerating objects: 6437, done.Counting objects: 100% (6437/6437), done.Delta compression using up to 12 threadsCompressing objects: 100% (2773/2773), done.Writing objects: 100% (6350/6350), 5.22 MiB | 4.21 MiB/s, done.Total 6350 (delta 3679), reused 6079 (delta 3467), pack-reused 0remote: Resolving deltas: 100% (3679/3679), completed with 55 local objects.To https://github.com/HanbiJang/new_repo.git * [new branch] master -&gt; master * [new reference] origin/HEAD -&gt; origin/HEAD * [new reference] origin/code-style-review -&gt; origin/code-style-review * [new reference] origin/docs -&gt; origin/docs * [new reference] origin/master -&gt; origin/master * [new reference] origin/production -&gt; origin/production * [new tag] v2.0 -&gt; v2.0 * [new tag] v2.1 -&gt; v2.1 * [new tag] v2.2 -&gt; v2.2 * [new tag] v2.2.1 -&gt; v2.2.1 * [new tag] v2.3 -&gt; v2.3 * [new tag] v2.4 -&gt; v2.4 * [new tag] v2.4.1 -&gt; v2.4.1 * [new tag] v2.4.2 -&gt; v2.4.2 * [new tag] v2.5 -&gt; v2.5 * [new tag] v2.5.1 -&gt; v2.5.1 * [new tag] v2.6.0 -&gt; v2.6.0 * [new tag] v2.6.1 -&gt; v2.6.1 * [new tag] v2.6.2 -&gt; v2.6.2 * [new tag] v2.7.0 -&gt; v2.7.0 * [new tag] v2.7.1 -&gt; v2.7.1 * [new tag] v2.7.2 -&gt; v2.7.2 * [new tag] v3.0.0 -&gt; v3.0.0 * [new tag] v3.0.1 -&gt; v3.0.1 * [new tag] v3.0.2 -&gt; v3.0.2 * [new tag] v3.0.3 -&gt; v3.0.3 * [new tag] v3.1.0 -&gt; v3.1.0 * [new tag] v3.1.1 -&gt; v3.1.1 * [new tag] v3.2.0 -&gt; v3.2.0 * [new tag] v3.2.1 -&gt; v3.2.1 * [new tag] v3.2.2 -&gt; v3.2.2 * [new tag] v3.3.0 -&gt; v3.3.0 * [new tag] v3.3.1 -&gt; v3.3.1 * [new tag] v3.3.2 -&gt; v3.3.2 * [new tag] v4.0.0 -&gt; v4.0.0 * [new tag] v4.0.1 -&gt; v4.0.1 * [new tag] v4.0.2 -&gt; v4.0.2 * [new tag] v4.1.0 -&gt; v4.1.0 * [new tag] v4.1.1 -&gt; v4.1.1 * [new tag] v4.2.0 -&gt; v4.2.0 * [new tag] v4.2.1 -&gt; v4.2.1 * [new tag] v4.3.0 -&gt; v4.3.0 * [new tag] v4.3.1 -&gt; v4.3.1 * [new tag] v4.3.2 -&gt; v4.3.2 * [new tag] v4.3.3 -&gt; v4.3.3 * [new tag] v4.3.4 -&gt; v4.3.4 * [new tag] v5.0.0 -&gt; v5.0.0 * [new tag] v5.0.1 -&gt; v5.0.1 * [new tag] v5.0.2 -&gt; v5.0.2 * [new tag] v5.1.0 -&gt; v5.1.0 ! [remote rejected] main (refusing to delete the current branch: refs/heads/main)error: failed to push some refs to 'https://github.com/HanbiJang/new_repo.git'아직도 한 줄 오류가 뜨긴 하지만 말끔히 master브랜치의 작업내역, 커밋 내역이 완벽히 복사가 되어 새브랜치 A에 만들어졌고, 잔디도 추가되었다!나는 귀찮아서 그냥 원래 작업하던 깃허브 레포지토리에서 작업할 것이므로, 여전히 잔디 표시가 안 될 것이다.이렇게 가끔 가다 bare clone , mirror push 를 해주면 그만이니 상관 없다.⇒ 수정! 전에 만들어둔 Fork된 레포지토리 명을 Username.github.io 에서 다른 것으로 바꾸고,해당 잔디 심기용 레포의 이름을 Username.github.io로 만든다!몇 분 후에 다시 깃허브 홈페이지가 만들어집니다.만약 Chirpy테마 블로그에서 문제가 있다면 다음 포스트에서 문제를 해결하면 됩니다 :)깃허브 블로그 오류 해결참고한 사이트들잔디심는 법 참조workflow scope 오류 해결 참조" }, { "title": "Jekyll _Chirpy테마 블로그 만들기", "url": "/posts/Jekyll-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/", "categories": "Jekyll", "tags": "Tutorial, Jekyll", "date": "2022-04-04 00:00:00 +0900", "snippet": "시작하기Jekyll 로 블로그를 만드는 방법은 인터넷에 구글링 하는 방법들을 따라하면 굉장히 오류가 많다.지금 내가 쓰고 있는 _Chirpy 테마 적용이 특히 그러하다._Chirpy 테마의 장점 💕이 테마가 좋은 점은 무려 카테고리, 태그, 댓글, 검색 기능이 자동으로 딸려있다는 점이다.블로그를 시작하기에 가장 적합한 테마라고 생각한다.깃허브 블로그 만들기테마 레포지토리 Fork하기수 많은 에러와 오류를 겪은 입장에서 그냥 테마 파일 통째로 Fork 하는 방식을 추천한다.일단 간단하게 _Chirpy테마 깃허브 에서 테마를 Fork 해주도록 하자.위 깃허브 사이트에 들어가서 우측의 Fork 버튼을 눌러주면 자동으로 내 깃허브 계정으로 레포지토리가 복사가 된다.나의 레포지토리 이름 변경하기그 후 복사 된 _Chirpy 레포지토리의 이름을 변경하면 된다.해당 레포지토리에 들어가서 위쪽에 위치한 Setting - General 설정에서 바꿔주면 된다깃허브 이름을 [당신의 Github Username].github.io 로 바꿔준다.그렇게 하면, 10분에서 길면 몇시간까지 (💢전 계속 안 되어서 포기하고 자고 일어나니까 만들어져있었음) 기다리면당신의 홈페이지가 만들어질 것이다. 이렇게 해서 당신의 깃허브 홈페이지 주소는 Username.github.io 가 된다.1. 주의할 점 : Username 에 대문자가 포함되어 있다면 모두 소문자로 바꿔주어야 합니다!2. 저는 제 Username도 모르겠어요이름은 나의 Github Username을 사용하면 되는데, 깃허브 우측 상단의 조그만 계정 프로필을 누르면 나오는 Signed in as [Username] 이 당신의 Username 이다._Chirpy 테마 적용하기이렇게 해서 당신의 깃허브 홈페이지 주소는 Username.github.io 가 된다.당연히 테마도 적용되어 있겠지?그런데 들어가면 ? 놀랍게도 아무것도 안 나온다! :-) ✨layout: home # Index Page --- — --- layout: home # Index Page ---.이런 문구만이 당신을 반긴다. (●’◡’●)당신은 블로그를 커스텀 하고 Git Bash를 설치하여 아래와 같은 작업을 해주어야 한다.블로그 커스텀하기chirpy 사이트에 있는 튜토리얼 대로 하면, 예상 못한 에러가 쏟아진다. 💔 수십번의 에러와 구글링을 통해 얻은 오류 없는 한방 해결 루트는 다음과 같다.1. Username.Github.io 레포지토리 Clone 하기내 컴퓨터로 해당 레포지토리를 Clone 해온다.2. 폴더 내용 커스텀하기_config.yml 파일을 메모장으로 열어준다.그 후 당신이 수정해야 하는 내용은 다음과 같다. 한 문장씩 찾아서 내용을 써주면 된다.---timezone: Asia/Seoultitle: 🎀블로그 타이틀🎀tagline: 블로그 설명(부제)url: 'https://Username.github.io'github: username: Usernamesocial: name: Username email: 당신의 이메일@gmail.com links: - https://github.com/Username---여기까지는 사실 다른 블로그 테마들과 다를 게 없다. 하지만 chirpy 테마는 남다르다… 그리고 아직! Github에 Push 하지 마세요!3. (💥필수💥)그 후, 당신이 클론한 블로그 레포지토리 폴더로 돌아와서 다음과 같은 작업 해주어야 한다.1) .github에서 pages-deploy 파일만 살리기경로: 당신 블로그 폴더 - .github (의 하위 폴더 workflows 포함)에서 pages-deploy.yml.hook 파일을 제외한 모든 파일을 삭제해줍니다.그 후에 pages-deploy.yml.hook 파일 이름 변경을 하여pages-deploy.yml 으로 뒤에 hook을 제거하여 확장자명 변경을 해줍니다. 이렇게 하고 Github에 push를 하려고 하면 workflows 권한 오류가 뜨면서 push가 안 될겁니다.당연함. 우리는 권한을 추가해줘야 합니다.2) workflows 권한 추가하기github 홈페이지 - Settings - Developer settings - Personal access tokens 에서Getnerate new token 을 하고 난후 또는, 이미 token이 있다면 해당 token을 클릭하고Edit personal access token - Select scopes - workflows 체크!이제 workflows Push 에러가 사라진다. 여기까지 해서 Github에 Push 해보자! 넉넉 잡아 1시간 내에 처리가 된다. 이제 당신의 블로그 홈페이지가 보일 수도 있다. 되면 좋겠지만 만약 안 된다면…3) Ruby, Gem 설치 후 bundle 추가하기여기까지 해서 작동이 안 된다면 당신은 코딩 추가 작업을 해주어야 한다. 이 작업을 해놓으면후에 Local 서버로 블로그 상태를 확인하는 실시간 작업을 할 수 있으므로 하는 것을 추천한다. (●’◡’●)1) Ruby 설치하기 가장 최신 버전으로 받아준다. 로컬 서버로 블로그를 돌릴 때 필요합니다. 그냥 받아두면 나중에 쓸 일이 있을 것.2) Gem 설치하기 이 녀석이 핵심입니다. 가장 최신 버전으로 받아준다.3) 없는 사람? Git Bash 설치하기[1] Git Bash를 열고 클론한 깃허브 블로그 폴더 경로로 들어가준다.cd 블로그-폴더-경로…[2] 그 후 다음을 입력bash tools/init.sh 오류 나도 그냥 따라오세요[3] 다음을 입력bundle[4] 이제 Push를 해보세요! 여기까지 과정에 왔으면 이름이 gh-pages 인 새 브런치가 만들어져 있을겁니다! (이 부분이 반드시 되어있어야 함! ✨매우 매우 중요✨ ) 위 과정이 어떤 알 수 없는 에러로 안 되었다면 구글링을 통해서 꼭 해결해야 합니다. (…)4) 깃허브 블로그 Page 세팅하기당신의 블로그 레포지토리 - Settings - Pages - Source 에서Branch를 새로 만들어진 gh-pages로 변경합니다!Local 서버로 확인하기나는 그닥 사용하지 않지만 Local 서버로 홈페이지를 확인하고 싶다면 다음과 같이 하면 된다.오류 뜨시는 분들을 위해서 제가 오류해결을 정리한 티스토리 링크 남기고 갑니다(다음에 계속…)포스팅 해보기아래에 Jekyll 포스팅 튜토리얼을 번역한 글을 참조하시길 바랍니다…이 글의 당신의 블로그 생활에 도움이 되길 (●’◡’●)" }, { "title": "Jekyll 포스팅 튜토리얼 번역", "url": "/posts/jekyll-%ED%8F%AC%EC%8A%A4%ED%8C%85-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-%EB%B2%88%EC%97%AD/", "categories": "Jekyll", "tags": "Tutorial, Jekyll", "date": "2022-04-01 15:10:00 +0900", "snippet": "이 게시물은 Chirpy 테마에 대한 게시물을 작성하는 방법을 안내합니다. 이전에 _Jekyll_을 사용한 경험이 있더라도 이 기사는 읽을 가치가 있습니다. 많은 기능에서 특정 변수를 설정해야 하기 때문입니다.이름 지정 및 경로YYYY-MM-DD-TITLE.EXTENSION라는 이름의 파일을 생성하고. 블로그 폴더 내의 _posts 폴더에 집어넣습니다.파일의 확장자는 .md나 .markdown 이어야 합니다. 파일 생성 시간을 절약하려면 이 플러그인 Jekyll-Compose 을 사용하여 이를 수행하는 것이 좋습니다.머리말기본적으로 게시물 상단에 다음과 같은 머리말 을 작성해야 합니다.---title: 타이틀date: YYYY-MM-DD HH:MM:SS +/-TTTTcategories: [카테고리1, 카테고리2]tags: [태그1] # 태그 이름은 소문자여야합니다---주의 점! 게시물의 _레이아웃_은 기본적으로 설정되어 있으므로 머리말 블록에 layout : post 를 추가할 필요가 없습니다!날짜의 시간대게시물의 릴리즈 날짜를 정확히 기록하려면 _config.yml} 파일의 timezone설정을 해야합니다. 한국은 Asia/Soul 입니다. 또한 게시물의 타임존을 머리말 블록의 date에 제공합니다. 형식은 +/-TTTT 예를들어 +0800 같이카테고리와 태그각 categories포스트의 요소는 최대 2개의 요소를 포함하도록 설계되었으며 요소의 tags수는 0에서 무한대일 수 있습니다. 예를 들어:---categories: [Animal, Insect]tags: [bee]---작성자 정보게시물의 작성자 정보는 일반적으로 _머리말_에 입력할 필요가 없으며 기본적으로 _config.yml 파일의 social.name 변수와 social.links의 첫 번째 항목에서 가져옵니다._data/authors.yml 에 작성자 정보를 추가하는 것을 통해 재정의 가능합니다 (웹 사이트에 이 파일이 없으면 주저하지 말고 작성하세요!)&lt;author_id&gt;: name: &lt;full name&gt; twitter: &lt;twitter_of_author&gt; url: &lt;homepage_of_author&gt;그런 다음 게시물의 YAML 블록에서 사용자 지정 작성자를 설정합니다---author: &lt;author_id&gt;--- _data/authors.yml 파일에서 작성 정보를 읽는 방식의 장점은 페이지가 twitter:creator 메타 태그를 가지게 되어 Twitter Cards를 풍부하게 하고 검색엔진 최적화에 좋다는 것입니다.목차 만들기목차는 오른쪽 패널에 표시됩니다. 블로그 전체에서 목차를 끄려면 _config.yml에서 아래와 같이 toc 값을 false 로 수정합니다. 특정 게시물에서만 목차를 끄려면 머릿말 에 아래 코드와 같이 씁니다.(머릿말)---toc: false---댓글댓글을 전역으로 바꾸는 것은 _config.yml 파일의 comments.active 변수로 정의할 수 있습니다.이 변수를 true 로 설정하면 모든 게시물에 대한 댓글 기능이 켜집니다.특정 게시물에 대한 댓글만 닫으려면 머릿말 에 다음 코드를 추가하면 됩니다.---comments: false---수학 식For website performance reasons, the mathematical feature won’t be loaded by default. But it can be enabled by:성능 상의 이유로 수학식은 기본적으로 로드되지 않습니다. 그러나 다음을 통해 활성화 할 수 있습니다.---math: true---MermaidMermaid는 훌륭한 다이어그램 생성 도구입니다. 게시물에서 활성화 하려면 다음(아래) 코드를 추가합니다.---mermaid: true---그러면 다른 마크다운 언어처럼 그래프 코드를 ```mermaid 와 ```로 묶습니다.이미지이미지의 캡션이미지의 다음 줄에 이탤릭체 글씨를 추가하면 이미지 하단에 나타나 캡션 역할을 합니다.![img-description](/path/to/image)_Image Caption_이미지의 사이즈이미지가 로드될 때 페이지 콘텐츠 레이아웃이 이동되는 것을 방지라혀면, 각 이미지의 너비와 높이를 설정해주어야 합니다.![Desktop View](/assets/img/sample/mockup.png){: width=\"700\" height=\"400\" }_Chirpy 버전 5.0.0 부터 너비와 높이가 약어를 지원합니다.너비 -&gt; w, 높이 -&gt; h![Desktop View](/assets/img/sample/mockup.png){: w=\"700\" h=\"400\" }이미지의 위치기본적으로 이미지는 중앙에 위치하지만 normal, left, right 클래스 중 하나를 사용하여 위치를 지정할 수 있습니다. 위치가 지정되면 이미지 캡션을 추가하면 안 됩니다. Normal 위치 Image will be left aligned in below sample: ![Desktop View](/assets/img/sample/mockup.png){: .normal } left 위치 ![Desktop View](/assets/img/sample/mockup.png){: .left } right 위치 ![Desktop View](/assets/img/sample/mockup.png){: .right } 이미지 그림자이미지 창은 그림자 효과를 표시할 수 있으며, 그림자는 light 모드에서 볼 수 있습니다.![Desktop View](/assets/img/sample/mockup.png){: .shadow }이미지 CDN URLCDN에 이미지를 호스팅하는 경우 _config.yml 파일의 img_cdn 변수를 할당하여 CDN URL을 반복적으로 작성하는 시간을 절약할 수 있습니다.img_cdn: https://cdn.comimg_cdn이 지정되면 /로 시작하는 모든 이미지(사이트 아바타 및 게시물의 이미지)의 경로에 CDN URL이 추가됩니다.예를 들어 이미지를 사용할 때 이렇게 쓸 수 있습니다:![The flower](/path/to/flower.png)처리된 결과는 다음처럼 이미지 경로 앞에 CDN 접두사 https://cdn.com을 자동으로 추가합니다.&lt;img src=\"https://cdn.com/path/to/flower.png\" alt=\"The flower\"&gt;이미지 경로게시물에 많은 이미지가 포함된 경우 이미지의 경로를 반복적으로 정의하는 것은 시간이 많이 걸리는 작업입니다. 이 문제를 해결하기 위해 게시물의 말머리 에서 이 경로를 정의할 수 있습니다.---img_path: /img/path/---그러면, Markdown의 이미지 소스는 파일 이름만 써도 표시됩니다.![The flower](flower.png)처리된 결과는 다음과 같습니다.&lt;img src=\"/img/path/flower.png\" alt=\"The flower\"&gt;미리보기 이미지게시물 콘텐츠 상단에 이미지를 추가하려면 이미지의 path, width, height 및 alt 속성을 지정하세요.---image: path: /path/to/image/file width: 1000 # in pixels height: 400 # in pixels alt: 이미지 대체 텍스트---alt를 제외한 다른 모든 옵션, 특히 사용자 경험 및 웹 페이지 로딩 성능과 관련된 width 및 height가 필요합니다. 위의 “ 이미지의 사이즈” 섹션에서도 이에 대해 언급하고 있습니다._Chirpy v5.0.0_부터 height 및 width 속성은 height → h, width → w로 축약될 수 있습니다. 또한 이미지 경로도 미리보기 이미지에 전달할 수 있습니다. 즉, 설정되면 path 속성은 이미지 파일 이름만 필요합니다.게시물 메인에 고정하기하나 이상의 게시물을 홈페이지 상단에 고정할 수 있으며, 고정 게시물은 출시일에 따라 역순으로 정렬됩니다.다음으로 활성화 가능합니다.---pin: true---Prompts프롬프트에는 tip, info, warning 및 danger와 같은 여러 유형이 있습니다. 블록 인용에 prompt-{type} 클래스를 추가하여 생성할 수 있습니다. 예를 들어 info 유형의 프롬프트를 다음과 같이 정의합니다.&gt; Example line for prompt.{: .prompt-info }Syntax인라인 코드`inline code part`파일 경로 하이라이트{: .filepath} 을 붙이면 됩니다.`/path/to/a/file.extend`{: .filepath}코드 블록마크다운 기호 ```는 다음과 같이 코드 블록을 쉽게 생성할 수 있습니다.```This is a plaintext code snippet.```언어 지정하기. ```{language} 를 사용하면 구문 강조 표시가 있는 코드 블록이 표시 됩니다만, 이 테마에선 지원하지 않습니다.```yamlkey: value``` Jekyll 태그 Highlight는 이 테마와 호환되지 않습니다.라인 넘버기본적으로 plaintext, console 및 terminal을 제외한 모든 언어는 줄 번호를 표시합니다. 코드 블록의 줄 번호를 숨기려면 ‘nolineno’ 클래스를 추가하세요.```shellecho 'No more line numbers!'```{: .nolineno }파일명을 지정하기코드 블록의 맨 위에 코드 언어가 표시되는 것을 보셨을 것입니다. 파일 이름으로 바꾸려면 코드블럭 밑에 file 속성을 추가하여 이를 달성할 수 있습니다.```shell# content```{: file=\"path/to/file\" }Liquid CodesLiquid 스니펫을 표시하려면 Liquid Codes를 {% raw %} 및 {% endraw %}로 묶습니다.{% raw %}```liquid{% if product.title contains 'Pack' %} This product's title contains the word Pack.{% endif %}```{% endraw %}표시하지 않으려면, 게시물의 YAML 블록에 render_with_liquid: false(Jekyll 4.0 이상 필요)를 추가합니다.더 자세한 설명…자세한 내용은 다음에서 확인하세요. Jekyll Docs: Posts." }, { "title": "첫 포스트", "url": "/posts/Hello!/", "categories": "", "tags": "", "date": "2022-03-31 15:00:00 +0900", "snippet": "반가워요Hello World! 첫 포스트 입니다." } ]
