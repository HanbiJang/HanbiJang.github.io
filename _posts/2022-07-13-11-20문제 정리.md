---
layout: post
title: 11~20번 중요 포인트

categories: [CodingTestStudy]
tags: [CodingTestStudy]
render_with_liquid: false
---

# 11~20번 중요 포인트

## 13번 가장 많이 사용된 자릿수

숫자열을 받고, 그 숫자열에서 가장 많이 쓴 자연수를 구해라

⇒ 힌트 : 자연수의 인덱스에 해당하는 0~ 9까지의 배열을 만들고 해당 인덱스의 수를 문자열을 만날 때마다 증가시킨다

```csharp

#include <stdio.h>
int ch[10];

int main(){
	int i, digit, max = -214000000, res;
	char a[101];

	scanf("%s", &a);
	for(i=0; a[i]!= '\0';i++){
		if(ch[i]>=max){
			max = ch[i];
			res = i;
		}

	printf("%d", res);
	return 0;
	}
}
```

## 14 뒤집힌 소수

```csharp
#include <stdio.h>

int reverse(int x){
	int res = 0, tmp = 0;
	while(x>0) {
		tmp = x % 10;
		res = res*10 + tmp;
		x = x/10;
	}
	return res;
}

//소수판별
bool isPrime( int x ){
	int i;
	if(x==1) return false;
	bool flag = true;
	for (i = 2; i<x; i++){
			if(x%i == 0) flag=false; break;
	}
	return flag;
}

int main(){
	int n, num, i ,newNum;
	scanf("%d", &n);

	for(i=0; i<=n; i++){
		scanf("%d", &num);
		newNum= reverse(num);
		if(isPrime(tmp)) printf("%d", tmp);
	}
	return 0;

}
```

**reverse** 가 중요함  (맨날 헷갈리는 문제중 하나)

++) 입력 수가 여러개면 그만큼 여러개 돌아가게 됨!

입력 수, 결과, tmp 필요함

1. 결과 = 뒤집힌 수가 결과로 들어옴
2. tmp =  숫자의 맨 뒷 숫자

입력 수는 반복문 한번이 지날때마다 맨뒷숫자가 사라짐.

tmp = 입력 수 %10

결과 = 이전결과 * 10 + 맨뒷숫자

입력수의 맨뒷숫자 날리기

(입력수가 0이 아니게 될때까지 반복)

## 15번 소수의 갯수 (1초)

**시간 초과 주의 !**

내 방법 :sqart 사용하기 🙅‍♀️

정답: sqart 사용 안하고 풀기⭕

```csharp
//sqart 사용 안하기!

for(j = 2; **j * j <= i**; j++){

	//...
}
```

## 16번 아나그램 (Anagram) (구글 인터퓨 문제)

⇒ 두 문자열을 비교해서 문자의 구성이 같으면 트루, 아니면 팔스를 출력한다

### 구성 비교 풀이 방법

배열을 비교할 만큼 만들어서 반복문 돌려서 인덱스에 넣고 비교한다

이 문제에서는 a 배열에 문자들을 넣고 반복문 하나하나 돌려서 구성이 있으면 카운트한다

### 프로그램 종료

함수를 안 쓰고  main 에서 프로그램을 종료하기

```csharp
exit(0);
```

⇒ 이거하면 `return 0;` 을 만나지 않아도 프로그램 종료됨

### 아스키 코드

대문자 : 65 ~ 90

소문자 : 97~ 122

![5C468870-5EA0-4705-8DA8-DD9B2A0F6F6A.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0dc14bcb-3928-41c3-a1f0-a66e5b3e4d50/5C468870-5EA0-4705-8DA8-DD9B2A0F6F6A.jpeg)

## 17번 선생님 퀴즈

한번에 여러개 변수 입력 받기 ⚠️까먹지 말기

```cpp
scanf("%d %d", &a, &b);
```

**C++ 서식 문자 정리**

| 서식 문자 |  타입 |
| --- | --- |
| %d | int |
| %c | char |
| %s | char* |
| %lf | double |
| %f | float |

### 18번 층간 소음

로직이 중요

- 문제 : 한 세대의 측정치가 M값을 넘으면 경보음이 울린다. 한 세대의 N초 동안의 실시간 측정치가 주어지면 최대로 경보음이 울린 시간은? (단, 경보음이 없다면 -1을 출력하기)
- 해답 로직 : 반복문을 돌리며 현재 측정치가 M값을 넘으면 카운트한다. 이때 카운트가 최대 값보다 크다면 최대값은 카운트값으로 한다. 출력은 최대값으로 한다
- ⚠️주의할 점 : 예외 처리 - -1 출력하기 ⇒ 위 반복문을 이후에도 max값이 처음과 변함이 없다면 결과를 -1로 출력

### 19번 분노 유발자

- 문제 : 앉은 키들이 주어짐. 한줄로 앉은 학생들 에 대해서 앞 사람이 뒷사람 **모두를** 못보게 가리는 분노유발자들을 카운트해서 출력해라
- 앞→ 뒤로 비교하는 방법의 문제점: 학생 한명 당 뒷사람의 키가 더큰지 아닌지 모르기때문에 나머지 뒷사람들에 대해서도 비교를 해주어야 하므로 반복문이 2개나 쓰임
- 뒤→ 앞 비교하는 방법 : 위를 해결함. 뒤에서 부터 비교하여 가장 큰 학생의 키만 저장해놓으면 앞으로 가며 비교하므로 해당 학생이 분노 유발자인지 아닌지 구별 가능함

### 20번 가위바위보

로직이 중요함

가위바위보의 승리를 비교하는 비교문이 적어야 깨끗한 코드됨

**⇒ 한명의 입장에서만 이기는 경우를 센다면 그 이외의 경우는 (=else) 다른 사람이 이기는 경우다**

if(비기는 경우)

else if(A가 보자기로 이김)

else if(A가 가위로 이김)

else if(A가 바위로 이김)

else == A가 지는 모든 경우

⇒ 누구든지 상관없이, 이겼을때와 졌을때가 해주는 액션이 동일하므로 이렇게 깔끔하게 가능함
